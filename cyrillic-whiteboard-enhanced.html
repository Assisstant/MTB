<!DOCTYPE html>
<html lang="mk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–∏—Ä–∏–ª–∏—á–Ω–∞ –¢–∞–±–ª–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #1e293b;
            --bg-darker: #0f172a;
            --bg-light: #334155;
            --bg-lighter: #475569;
            --text-light: #e2e8f0;
            --text-muted: #94a3b8;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #eab308;
            --purple: #a855f7;
            --pink: #ec4899;
            --canvas-bg: #e2e8f0;
            --grid-color: rgba(100, 116, 139, 0.15);
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-darker);
            color: var(--text-light);
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* ============ TOOLBAR ============ */
        .toolbar {
            background: var(--bg-darker);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid var(--bg-light);
            flex-shrink: 0;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .toolbar-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-light);
            white-space: nowrap;
        }

        .toolbar-scroll {
            display: flex;
            align-items: center;
            gap: 8px;
            overflow-x: auto;
            flex: 1;
            padding-bottom: 4px;
        }

        .toolbar-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .toolbar-scroll::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        .toolbar-scroll::-webkit-scrollbar-thumb {
            background: var(--bg-lighter);
            border-radius: 2px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--bg-light);
            flex-shrink: 0;
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .btn-icon {
            padding: 6px;
            min-width: 32px;
            min-height: 32px;
        }

        .btn-default {
            background: var(--bg-light);
            color: var(--text-light);
        }

        .btn-default:hover {
            background: var(--bg-lighter);
        }

        .btn-default:disabled {
            background: var(--bg-dark);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-purple {
            background: var(--purple);
            color: white;
        }

        .btn-purple:hover {
            background: #9333ea;
        }

        .btn.active {
            background: var(--primary);
            color: white;
        }

        .btn.active-green {
            background: var(--success);
            color: white;
        }

        .btn.active-rose {
            background: var(--danger);
            color: white;
        }

        /* Slider control */
        .slider-control {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-light);
            padding: 4px 10px;
            border-radius: 6px;
        }

        .slider-control label {
            font-size: 11px;
            color: var(--text-muted);
        }

        .slider-control input[type="range"] {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--bg-lighter);
            border-radius: 2px;
            cursor: pointer;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        /* Color palette */
        .color-palette {
            display: flex;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-light);
            border-radius: 6px;
        }

        .color-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .color-btn:hover {
            transform: scale(1.2);
        }

        /* ============ MAIN CANVAS AREA ============ */
        .main-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            background: #cbd5e1;
        }

        .canvas {
            position: relative;
            width: 4000px;
            height: 3000px;
            background-color: var(--canvas-bg);
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .canvas.mode-drawing {
            cursor: crosshair;
        }

        .canvas.mode-painting {
            cursor: pointer;
        }

        .canvas.mode-typing {
            cursor: text;
        }

        /* ============ ELEMENTS ON CANVAS ============ */
        .element {
            position: absolute;
            user-select: none;
        }

        .element-letter {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: grab;
            transition: border-color 0.1s;
        }

        .element-letter:active {
            cursor: grabbing;
        }

        .element-letter.selected {
            border-color: var(--primary);
        }

        .element-image {
            padding: 4px;
            background: white;
            border: 2px solid transparent;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: grab;
        }

        .element-image:active {
            cursor: grabbing;
        }

        .element-image.selected {
            border-color: var(--primary);
        }

        .element-image img {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .image-resize-handle {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
        }

        .element-line {
            height: 8px;
            cursor: pointer;
        }

        .element-line .line-bar {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            height: 2px;
            background: var(--bg-dark);
            transition: height 0.1s;
        }

        .element-line:hover .line-bar,
        .element-line.selected .line-bar {
            height: 4px;
        }

        .line-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 50%;
            cursor: ew-resize;
            display: none;
        }

        .element-line.selected .line-handle {
            display: block;
        }

        .line-handle-left {
            left: -5px;
        }

        .line-handle-right {
            right: -5px;
        }

        /* Selection box */
        .selection-box {
            position: absolute;
            border: 2px solid var(--primary);
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        /* Drawing line preview */
        .drawing-line-preview {
            position: absolute;
            height: 2px;
            background: var(--primary);
            opacity: 0.8;
            pointer-events: none;
        }

        /* Typing cursor */
        .typing-cursor {
            position: absolute;
            width: 2px;
            background: var(--primary);
            animation: blink 1s infinite;
            pointer-events: none;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* ============ KEYBOARD ============ */
        .keyboard {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            user-select: none;
            z-index: 100;
        }

        .keyboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--bg-light);
            cursor: default;
        }

        .keyboard-header.draggable {
            cursor: grab;
        }

        .keyboard-header.draggable:active {
            cursor: grabbing;
        }

        .keyboard-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
        }

        .keyboard-controls {
            display: flex;
            gap: 6px;
        }

        .keyboard-body {
            padding: 10px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 4px;
        }

        .keyboard-row:last-child {
            margin-bottom: 0;
        }

        .key {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-light);
            color: var(--text-light);
            border-radius: 4px;
            cursor: grab;
            transition: background 0.15s;
            font-weight: 500;
        }

        .key:hover {
            background: var(--bg-lighter);
        }

        .key:active {
            cursor: grabbing;
        }

        .key-special {
            cursor: pointer;
        }

        .key-caps.active {
            background: var(--primary);
        }

        .keyboard-resize-handle {
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            opacity: 0.5;
            transition: opacity 0.15s;
        }

        .keyboard-resize-handle:hover {
            opacity: 1;
        }

        .keyboard-resize-handle svg {
            width: 100%;
            height: 100%;
            fill: var(--text-muted);
        }

        /* ============ TOAST NOTIFICATION ============ */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-dark);
            color: var(--text-light);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
        }

        /* ============ ICONS (SVG) ============ */
        .icon {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .icon-sm {
            width: 14px;
            height: 14px;
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-left">
                <span class="toolbar-title" data-i18n="title">–ö–∏—Ä–∏–ª–∏—á–Ω–∞ –¢–∞–±–ª–∞</span>
                <button class="btn btn-default btn-icon" id="langToggle">EN</button>
            </div>
            
            <div class="toolbar-scroll">
                <div class="toolbar-group">
                    <button class="btn btn-default btn-icon" id="undoBtn" disabled title="–í—Ä–∞—Ç–∏">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                    </button>
                    <button class="btn btn-default btn-icon" id="redoBtn" disabled title="–ü–æ–≤—Ç–æ—Ä–∏">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group" id="selectionTools" style="display:none;">
                    <div class="color-palette" id="colorPalette"></div>
                    <button class="btn btn-danger btn-icon" id="deleteBtn" title="–ò–∑–±—Ä–∏—à–∏">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                    </button>
                    <div class="toolbar-divider"></div>
                </div>

                <div class="toolbar-group">
                    <button class="btn btn-default btn-icon" id="paintBtn" title="–ë–æ–µ—ö–µ">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 00-1.41 0L9 12.25 11.75 15l8.96-8.96a.996.996 0 000-1.41z"/></svg>
                    </button>
                    <button class="btn btn-default btn-icon" id="typeBtn" title="–ü–∏—à—É–≤–∞—ö–µ">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z"/></svg>
                    </button>
                    <button class="btn btn-default btn-icon" id="lineBtn" title="–õ–∏–Ω–∏—ò–∞">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M4 11h16v2H4z"/></svg>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <button class="btn btn-default" id="snapBtn">
                    <span data-i18n="snap">–õ–µ–ø–µ—ö–µ</span>: <span id="snapStatus" data-i18n="on">–í–ö–õ</span>
                </button>

                <div class="slider-control">
                    <label data-i18n="spacing">–†–∞—Å—Ç–æ—ò–∞–Ω–∏–µ</label>
                    <input type="range" id="spacingSlider" min="-30" max="50" value="2">
                </div>

                <button class="btn btn-default btn-icon" id="alignBtn" disabled title="–ü–æ—Ä–∞–º–Ω–∏">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/></svg>
                </button>

                <div class="slider-control" id="sizeControl">
                    <span style="font-size:12px">A</span>
                    <input type="range" id="sizeSlider" min="50" max="200" value="100" disabled>
                    <span style="font-size:18px">A</span>
                </div>

                <div class="toolbar-divider"></div>

                <button class="btn btn-success btn-icon" id="saveBtn" title="–ó–∞—á—É–≤–∞—ò">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>
                </button>
                <button class="btn btn-purple" id="keyboardToggle">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/></svg>
                    <span id="keyboardToggleText" data-i18n="hide">–°–æ–∫—Ä–∏—ò</span>
                </button>
            </div>
        </div>

        <!-- Main canvas area -->
        <div class="main-area">
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas" id="canvas"></div>
            </div>

            <!-- Keyboard -->
            <div class="keyboard" id="keyboard">
                <div class="keyboard-header" id="keyboardHeader">
                    <span class="keyboard-title">üá≤üá∞ <span data-i18n="macedonianKeyboard">–ú–∞–∫–µ–¥–æ–Ω—Å–∫–∞ –¢–∞—Å—Ç–∞—Ç—É—Ä–∞</span></span>
                    <div class="keyboard-controls">
                        <button class="btn btn-default btn-icon" id="lockBtn" title="–ó–∞–∫–ª—É—á–∏">
                            <svg class="icon icon-sm" viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>
                        </button>
                    </div>
                </div>
                <div class="keyboard-body" id="keyboardBody"></div>
                <div class="keyboard-resize-handle" id="keyboardResize">
                    <svg viewBox="0 0 24 24"><path d="M22 22H20V20H22V22ZM22 18H20V16H22V18ZM18 22H16V20H18V22ZM22 14H20V12H22V14ZM18 18H16V16H18V18ZM14 22H12V20H14V22Z"/></svg>
                </div>
            </div>
        </div>

        <!-- Toast -->
        <div class="toast" id="toast"></div>
    </div>

    <script>
        // ============ TRANSLATIONS ============
        const i18n = {
            mk: {
                title: '–ö–∏—Ä–∏–ª–∏—á–Ω–∞ –¢–∞–±–ª–∞',
                snap: '–õ–µ–ø–µ—ö–µ',
                on: '–í–ö–õ',
                off: '–ò–°–ö–õ',
                spacing: '–†–∞—Å—Ç–æ—ò–∞–Ω–∏–µ',
                hide: '–°–æ–∫—Ä–∏—ò',
                show: '–ü–æ–∫–∞–∂–∏',
                macedonianKeyboard: '–ú–∞–∫–µ–¥–æ–Ω—Å–∫–∞ –¢–∞—Å—Ç–∞—Ç—É—Ä–∞',
                saved: '–ó–∞—á—É–≤–∞–Ω–æ!',
                caps: '–ì–æ–ª–µ–º–∏'
            },
            en: {
                title: 'Cyrillic Whiteboard',
                snap: 'Snap',
                on: 'ON',
                off: 'OFF',
                spacing: 'Spacing',
                hide: 'Hide',
                show: 'Show',
                macedonianKeyboard: 'Macedonian Keyboard',
                saved: 'Saved!',
                caps: 'Caps'
            }
        };

        let currentLang = 'mk';

        function t(key) {
            return i18n[currentLang][key] || key;
        }

        function updateLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });
            document.getElementById('snapStatus').textContent = state.autoSnap ? t('on') : t('off');
            document.getElementById('keyboardToggleText').textContent = state.keyboardVisible ? t('hide') : t('show');
            document.getElementById('langToggle').textContent = currentLang === 'mk' ? 'EN' : 'MK';
        }

        // ============ STATE ============
        const state = {
            elements: [],
            selectedIds: [],
            history: { past: [], future: [] },
            mode: null, // 'drawing', 'painting', 'typing'
            autoSnap: true,
            letterSpacing: 2,
            keyboardVisible: true,
            keyboardLocked: true,
            keyboardCaps: false,
            typingCursor: { x: 100, y: 100, fontSize: 48 }
        };

        const SNAP_THRESHOLD = 15;
        const NEIGHBOR_RADIUS = 150;

        // ============ DOM ELEMENTS ============
        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const keyboard = document.getElementById('keyboard');
        const keyboardBody = document.getElementById('keyboardBody');
        const keyboardHeader = document.getElementById('keyboardHeader');
        const toast = document.getElementById('toast');

        // ============ UTILITY FUNCTIONS ============
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        function saveToHistory() {
            state.history.past.push(JSON.stringify(state.elements));
            if (state.history.past.length > 20) state.history.past.shift();
            state.history.future = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.history.past.length === 0) return;
            state.history.future.push(JSON.stringify(state.elements));
            state.elements = JSON.parse(state.history.past.pop());
            state.selectedIds = [];
            renderElements();
            updateUndoRedoButtons();
            updateSelectionTools();
        }

        function redo() {
            if (state.history.future.length === 0) return;
            state.history.past.push(JSON.stringify(state.elements));
            state.elements = JSON.parse(state.history.future.pop());
            state.selectedIds = [];
            renderElements();
            updateUndoRedoButtons();
            updateSelectionTools();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = state.history.past.length === 0;
            document.getElementById('redoBtn').disabled = state.history.future.length === 0;
        }

        function updateSelectionTools() {
            const selectionTools = document.getElementById('selectionTools');
            const alignBtn = document.getElementById('alignBtn');
            const sizeSlider = document.getElementById('sizeSlider');
            
            if (state.selectedIds.length > 0) {
                selectionTools.style.display = 'flex';
                const selectedLetters = state.elements.filter(el => 
                    state.selectedIds.includes(el.id) && el.type === 'letter'
                );
                alignBtn.disabled = selectedLetters.length < 2;
                sizeSlider.disabled = selectedLetters.length === 0;
                
                if (selectedLetters.length > 0) {
                    const scale = (selectedLetters[0].fontSize / 48) * 100;
                    sizeSlider.value = scale;
                }
            } else {
                selectionTools.style.display = 'none';
                alignBtn.disabled = true;
                sizeSlider.disabled = true;
                sizeSlider.value = 100;
            }
        }

        // ============ FIND NEAREST LETTER PROPERTIES ============
        function findNearestLetterProps(x, y) {
            const letters = state.elements.filter(el => el.type === 'letter');
            if (letters.length === 0) return { fontSize: 48, spacing: state.letterSpacing };

            let nearest = null;
            let minDist = Infinity;

            for (const letter of letters) {
                const cx = letter.x + letter.width / 2;
                const cy = letter.y + letter.fontSize / 2;
                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                if (dist < NEIGHBOR_RADIUS && dist < minDist) {
                    minDist = dist;
                    nearest = letter;
                }
            }

            if (!nearest) return { fontSize: 48, spacing: state.letterSpacing };

            // Find spacing from same-line letters
            const sameLine = letters.filter(l => Math.abs(l.y - nearest.y) < 10).sort((a, b) => a.x - b.x);
            let detectedSpacing = state.letterSpacing;
            
            if (sameLine.length >= 2) {
                let totalGap = 0, count = 0;
                for (let i = 1; i < sameLine.length; i++) {
                    const gap = sameLine[i].x - (sameLine[i-1].x + sameLine[i-1].width);
                    if (gap > -20 && gap < 100) {
                        totalGap += gap;
                        count++;
                    }
                }
                if (count > 0) detectedSpacing = totalGap / count;
            }

            return {
                fontSize: nearest.fontSize,
                spacing: detectedSpacing,
                color: nearest.color,
                nearest
            };
        }

        // ============ RENDER ELEMENTS ============
        function renderElements() {
            // Clear canvas except for dynamic elements
            canvas.querySelectorAll('.element').forEach(el => el.remove());
            canvas.querySelectorAll('.selection-box').forEach(el => el.remove());
            canvas.querySelectorAll('.drawing-line-preview').forEach(el => el.remove());
            canvas.querySelectorAll('.typing-cursor').forEach(el => el.remove());

            for (const el of state.elements) {
                const dom = createElementDOM(el);
                canvas.appendChild(dom);
            }

            // Render typing cursor if in typing mode
            if (state.mode === 'typing') {
                const cursor = document.createElement('div');
                cursor.className = 'typing-cursor';
                cursor.style.left = state.typingCursor.x + 'px';
                cursor.style.top = state.typingCursor.y + 'px';
                cursor.style.height = (state.typingCursor.fontSize * 1.2) + 'px';
                canvas.appendChild(cursor);
            }
        }

        function createElementDOM(el) {
            if (el.type === 'letter') {
                const div = document.createElement('div');
                div.className = 'element element-letter' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.fontSize = el.fontSize + 'px';
                div.style.color = el.color || '#1e293b';
                div.textContent = el.content === ' ' ? '\u00A0' : el.content;
                
                setupLetterDrag(div, el);
                return div;
            }

            if (el.type === 'line') {
                const div = document.createElement('div');
                div.className = 'element element-line' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = (el.y - 4) + 'px';
                div.style.width = el.width + 'px';
                
                const bar = document.createElement('div');
                bar.className = 'line-bar';
                bar.style.backgroundColor = el.color || '#1e293b';
                div.appendChild(bar);

                const leftHandle = document.createElement('div');
                leftHandle.className = 'line-handle line-handle-left';
                div.appendChild(leftHandle);

                const rightHandle = document.createElement('div');
                rightHandle.className = 'line-handle line-handle-right';
                div.appendChild(rightHandle);

                setupLineDrag(div, el, leftHandle, rightHandle);
                return div;
            }

            if (el.type === 'image') {
                const div = document.createElement('div');
                div.className = 'element element-image' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = el.width + 'px';
                div.style.height = el.height + 'px';

                const img = document.createElement('img');
                img.src = el.content;
                div.appendChild(img);

                if (state.selectedIds.includes(el.id)) {
                    const handle = document.createElement('div');
                    handle.className = 'image-resize-handle';
                    div.appendChild(handle);
                    setupImageResize(handle, el);
                }

                setupImageDrag(div, el);
                return div;
            }

            return document.createElement('div');
        }

        // ============ DRAG HANDLERS ============
        function setupLetterDrag(dom, el) {
            let startX, startY, origX, origY;
            let dragging = false;

            dom.addEventListener('mousedown', (e) => {
                e.stopPropagation();

                if (state.mode === 'painting') {
                    saveToHistory();
                    el.color = '#ef4444';
                    renderElements();
                    return;
                }

                // Selection
                if (e.shiftKey) {
                    if (state.selectedIds.includes(el.id)) {
                        state.selectedIds = state.selectedIds.filter(id => id !== el.id);
                    } else {
                        state.selectedIds.push(el.id);
                    }
                } else if (!state.selectedIds.includes(el.id)) {
                    state.selectedIds = [el.id];
                }
                updateSelectionTools();
                renderElements();

                dragging = true;
                startX = e.clientX;
                startY = e.clientY;
                origX = el.x;
                origY = el.y;

                const onMove = (e) => {
                    if (!dragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    // Move all selected
                    for (const id of state.selectedIds) {
                        const sel = state.elements.find(s => s.id === id);
                        if (sel && sel.id === el.id) {
                            sel.x = origX + dx;
                            sel.y = origY + dy;
                        }
                    }
                    renderElements();
                };

                const onUp = () => {
                    if (dragging) {
                        dragging = false;
                        saveToHistory();
                        
                        // Snap logic
                        if (state.autoSnap) {
                            snapElement(el);
                            renderElements();
                        }
                    }
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        function snapElement(el) {
            if (el.type !== 'letter') return;

            const lines = state.elements.filter(e => e.type === 'line');
            const letters = state.elements.filter(e => e.type === 'letter' && e.id !== el.id);

            // Snap to line (Y)
            const descenders = new Set(['—ò', '—Ä', '—É', '—Ñ', '—Ü', '—à', '—ï', '—ì', '—ú']);
            const hasDescender = descenders.has(el.content.toLowerCase());
            const baselineRatio = hasDescender ? 0.8 : 1.0;
            const height = el.fontSize * 1.2;
            const baselinePos = height * baselineRatio;

            for (const line of lines) {
                if (el.x + el.width > line.x && el.x < line.x + line.width) {
                    const elBaseline = el.y + baselinePos;
                    if (Math.abs(elBaseline - line.y) < SNAP_THRESHOLD) {
                        el.y = line.y - baselinePos;
                        break;
                    }
                }
            }

            // Snap to letter (X)
            for (const other of letters) {
                const snapX = other.x + other.width + state.letterSpacing;
                if (Math.abs(el.x - snapX) < SNAP_THRESHOLD) {
                    el.x = snapX;
                    break;
                }
            }
        }

        function setupLineDrag(dom, el, leftHandle, rightHandle) {
            dom.addEventListener('mousedown', (e) => {
                if (e.target === leftHandle || e.target === rightHandle) return;
                e.stopPropagation();

                if (e.shiftKey) {
                    if (state.selectedIds.includes(el.id)) {
                        state.selectedIds = state.selectedIds.filter(id => id !== el.id);
                    } else {
                        state.selectedIds.push(el.id);
                    }
                } else {
                    state.selectedIds = [el.id];
                }
                updateSelectionTools();
                renderElements();
            });

            // Resize handles
            const setupResize = (handle, isLeft) => {
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    const startX = e.clientX;
                    const origX = el.x;
                    const origWidth = el.width;

                    const onMove = (e) => {
                        const dx = e.clientX - startX;
                        if (isLeft) {
                            el.x = origX + dx;
                            el.width = Math.max(20, origWidth - dx);
                        } else {
                            el.width = Math.max(20, origWidth + dx);
                        }
                        renderElements();
                    };

                    const onUp = () => {
                        saveToHistory();
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };

                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            };

            setupResize(leftHandle, true);
            setupResize(rightHandle, false);
        }

        function setupImageDrag(dom, el) {
            let startX, startY, origX, origY;

            dom.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('image-resize-handle')) return;
                e.stopPropagation();

                state.selectedIds = [el.id];
                updateSelectionTools();
                renderElements();

                startX = e.clientX;
                startY = e.clientY;
                origX = el.x;
                origY = el.y;

                const onMove = (e) => {
                    el.x = origX + (e.clientX - startX);
                    el.y = origY + (e.clientY - startY);
                    renderElements();
                };

                const onUp = () => {
                    saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        function setupImageResize(handle, el) {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                const startX = e.clientX;
                const startY = e.clientY;
                const origW = el.width;
                const origH = el.height;

                const onMove = (e) => {
                    el.width = Math.max(50, origW + (e.clientX - startX));
                    el.height = Math.max(50, origH + (e.clientY - startY));
                    renderElements();
                };

                const onUp = () => {
                    saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        // ============ CANVAS INTERACTIONS ============
        let selectionStart = null;
        let drawingLine = null;

        canvas.addEventListener('mousedown', (e) => {
            if (e.target !== canvas) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + canvasContainer.scrollLeft;
            const y = e.clientY - rect.top + canvasContainer.scrollTop;

            if (state.mode === 'typing') {
                state.typingCursor.x = x;
                state.typingCursor.y = y;
                renderElements();
                return;
            }

            if (state.mode === 'drawing') {
                drawingLine = { x, y, width: 0 };
                return;
            }

            // Selection box
            state.selectedIds = [];
            updateSelectionTools();
            selectionStart = { x, y };
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + canvasContainer.scrollLeft;
            const y = e.clientY - rect.top + canvasContainer.scrollTop;

            if (drawingLine) {
                canvas.querySelectorAll('.drawing-line-preview').forEach(el => el.remove());
                const preview = document.createElement('div');
                preview.className = 'drawing-line-preview';
                const startX = Math.min(drawingLine.x, x);
                const width = Math.abs(x - drawingLine.x);
                preview.style.left = startX + 'px';
                preview.style.top = drawingLine.y + 'px';
                preview.style.width = width + 'px';
                canvas.appendChild(preview);
            }

            if (selectionStart) {
                canvas.querySelectorAll('.selection-box').forEach(el => el.remove());
                const box = document.createElement('div');
                box.className = 'selection-box';
                box.style.left = Math.min(selectionStart.x, x) + 'px';
                box.style.top = Math.min(selectionStart.y, y) + 'px';
                box.style.width = Math.abs(x - selectionStart.x) + 'px';
                box.style.height = Math.abs(y - selectionStart.y) + 'px';
                canvas.appendChild(box);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + canvasContainer.scrollLeft;
            const y = e.clientY - rect.top + canvasContainer.scrollTop;

            if (drawingLine) {
                const startX = Math.min(drawingLine.x, x);
                const width = Math.abs(x - drawingLine.x);
                if (width > 10) {
                    saveToHistory();
                    state.elements.push({
                        id: generateId(),
                        type: 'line',
                        x: startX,
                        y: drawingLine.y,
                        width,
                        color: '#1e293b'
                    });
                }
                drawingLine = null;
                setMode(null);
                renderElements();
            }

            if (selectionStart) {
                const x1 = Math.min(selectionStart.x, x);
                const x2 = Math.max(selectionStart.x, x);
                const y1 = Math.min(selectionStart.y, y);
                const y2 = Math.max(selectionStart.y, y);

                if (x2 - x1 > 5 || y2 - y1 > 5) {
                    state.selectedIds = state.elements.filter(el => {
                        if (el.type === 'line') {
                            return el.y >= y1 && el.y <= y2 && el.x < x2 && el.x + el.width > x1;
                        }
                        const elW = el.width || 50;
                        const elH = el.type === 'letter' ? el.fontSize * 1.2 : el.height;
                        return el.x < x2 && el.x + elW > x1 && el.y < y2 && el.y + elH > y1;
                    }).map(el => el.id);
                }

                selectionStart = null;
                updateSelectionTools();
                renderElements();
            }
        });

        // ============ DROP LETTERS ============
        canvas.addEventListener('dragover', (e) => e.preventDefault());
        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + canvasContainer.scrollLeft;
            const y = e.clientY - rect.top + canvasContainer.scrollTop;

            const data = e.dataTransfer.getData('text/plain');
            if (data) {
                try {
                    const { letter } = JSON.parse(data);
                    const props = findNearestLetterProps(x, y);
                    const fontSize = props.fontSize;
                    const width = fontSize * 0.7;

                    let finalX = x - width / 2;
                    let finalY = y - fontSize / 2;

                    // Snap to nearest letter
                    if (props.nearest && state.autoSnap) {
                        const snapX = props.nearest.x + props.nearest.width + props.spacing;
                        if (Math.abs(finalX - snapX) < 100) {
                            finalX = snapX;
                            finalY = props.nearest.y;
                        }
                    }

                    // Snap to line
                    if (state.autoSnap) {
                        const lines = state.elements.filter(el => el.type === 'line');
                        const descenders = new Set(['—ò', '—Ä', '—É', '—Ñ', '—Ü', '—à', '—ï', '—ì', '—ú']);
                        const hasDescender = descenders.has(letter.toLowerCase());
                        const baselineRatio = hasDescender ? 0.8 : 1.0;
                        const height = fontSize * 1.2;
                        const baselinePos = height * baselineRatio;

                        for (const line of lines) {
                            if (finalX + width > line.x && finalX < line.x + line.width) {
                                const elBaseline = finalY + baselinePos;
                                if (Math.abs(elBaseline - line.y) < SNAP_THRESHOLD * 3) {
                                    finalY = line.y - baselinePos;
                                    break;
                                }
                            }
                        }
                    }

                    saveToHistory();
                    state.elements.push({
                        id: generateId(),
                        type: 'letter',
                        content: letter,
                        x: finalX,
                        y: finalY,
                        fontSize,
                        width,
                        color: props.color || '#1e293b'
                    });
                    renderElements();
                } catch (err) {}
            }
        });

        // ============ KEYBOARD ============
        function renderKeyboard() {
            const fontSize = Math.max(14, Math.min(32, keyboard.offsetWidth / 20));
            const keySize = fontSize * 1.3;
            const gap = fontSize * 0.15;

            const rows = [
                ['—ô', '—ö', '–µ', '—Ä', '—Ç', '—ï', '—É', '–∏', '–æ', '–ø', '—à', '—ì'],
                ['–∞', '—Å', '–¥', '—Ñ', '–≥', '—Ö', '—ò', '–∫', '–ª', '—á', '—ú'],
                ['–∑', '—ü', '—Ü', '–≤', '–±', '–Ω', '–º']
            ];

            keyboardBody.innerHTML = '';
            keyboardBody.style.padding = (fontSize * 0.4) + 'px';

            for (const row of rows) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                rowDiv.style.gap = gap + 'px';
                rowDiv.style.marginBottom = gap + 'px';

                for (const char of row) {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.style.width = keySize + 'px';
                    key.style.height = keySize + 'px';
                    key.style.fontSize = (fontSize * 0.7) + 'px';
                    key.textContent = state.keyboardCaps ? char.toUpperCase() : char;
                    key.draggable = true;

                    key.addEventListener('dragstart', (e) => {
                        const letter = state.keyboardCaps ? char.toUpperCase() : char;
                        e.dataTransfer.setData('text/plain', JSON.stringify({ letter }));
                    });

                    rowDiv.appendChild(key);
                }
                keyboardBody.appendChild(rowDiv);
            }

            // Bottom row with Caps and Space
            const bottomRow = document.createElement('div');
            bottomRow.className = 'keyboard-row';
            bottomRow.style.gap = gap + 'px';

            const capsKey = document.createElement('div');
            capsKey.className = 'key key-special key-caps' + (state.keyboardCaps ? ' active' : '');
            capsKey.style.width = (keySize * 2) + 'px';
            capsKey.style.height = keySize + 'px';
            capsKey.style.fontSize = (fontSize * 0.55) + 'px';
            capsKey.textContent = t('caps');
            capsKey.addEventListener('click', () => {
                state.keyboardCaps = !state.keyboardCaps;
                renderKeyboard();
            });
            bottomRow.appendChild(capsKey);

            const spaceKey = document.createElement('div');
            spaceKey.className = 'key';
            spaceKey.style.width = (keySize * 6) + 'px';
            spaceKey.style.height = keySize + 'px';
            spaceKey.draggable = true;
            spaceKey.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ letter: ' ' }));
            });
            bottomRow.appendChild(spaceKey);

            keyboardBody.appendChild(bottomRow);
        }

        // Keyboard positioning and resizing
        function initKeyboard() {
            keyboard.style.width = '420px';
            keyboard.style.left = (window.innerWidth - 420) / 2 + 'px';
            keyboard.style.top = (window.innerHeight - 280) + 'px';
            renderKeyboard();
        }

        // Keyboard drag
        let kbDragging = false, kbOffsetX, kbOffsetY;

        keyboardHeader.addEventListener('mousedown', (e) => {
            if (state.keyboardLocked) return;
            kbDragging = true;
            kbOffsetX = e.clientX - keyboard.offsetLeft;
            kbOffsetY = e.clientY - keyboard.offsetTop;
            keyboardHeader.classList.add('draggable');
        });

        document.addEventListener('mousemove', (e) => {
            if (kbDragging) {
                keyboard.style.left = (e.clientX - kbOffsetX) + 'px';
                keyboard.style.top = (e.clientY - kbOffsetY) + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            kbDragging = false;
        });

        // Keyboard resize
        const kbResize = document.getElementById('keyboardResize');
        let kbResizing = false, kbStartW, kbStartX;

        kbResize.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            kbResizing = true;
            kbStartW = keyboard.offsetWidth;
            kbStartX = e.clientX;
        });

        document.addEventListener('mousemove', (e) => {
            if (kbResizing) {
                const newW = Math.max(280, Math.min(700, kbStartW + (e.clientX - kbStartX)));
                keyboard.style.width = newW + 'px';
                renderKeyboard();
            }
        });

        document.addEventListener('mouseup', () => {
            kbResizing = false;
        });

        // Lock button
        document.getElementById('lockBtn').addEventListener('click', () => {
            state.keyboardLocked = !state.keyboardLocked;
            keyboardHeader.classList.toggle('draggable', !state.keyboardLocked);
        });

        // ============ TOOLBAR BUTTONS ============
        function setMode(mode) {
            state.mode = mode;
            canvas.classList.remove('mode-drawing', 'mode-painting', 'mode-typing');
            document.getElementById('paintBtn').classList.remove('active-rose');
            document.getElementById('typeBtn').classList.remove('active-green');
            document.getElementById('lineBtn').classList.remove('active');

            if (mode === 'drawing') {
                canvas.classList.add('mode-drawing');
                document.getElementById('lineBtn').classList.add('active');
            } else if (mode === 'painting') {
                canvas.classList.add('mode-painting');
                document.getElementById('paintBtn').classList.add('active-rose');
            } else if (mode === 'typing') {
                canvas.classList.add('mode-typing');
                document.getElementById('typeBtn').classList.add('active-green');
            }
            renderElements();
        }

        document.getElementById('paintBtn').addEventListener('click', () => {
            setMode(state.mode === 'painting' ? null : 'painting');
        });

        document.getElementById('typeBtn').addEventListener('click', () => {
            setMode(state.mode === 'typing' ? null : 'typing');
        });

        document.getElementById('lineBtn').addEventListener('click', () => {
            setMode(state.mode === 'drawing' ? null : 'drawing');
        });

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);

        document.getElementById('snapBtn').addEventListener('click', () => {
            state.autoSnap = !state.autoSnap;
            document.getElementById('snapStatus').textContent = state.autoSnap ? t('on') : t('off');
            document.getElementById('snapBtn').classList.toggle('active-green', state.autoSnap);
        });

        document.getElementById('spacingSlider').addEventListener('input', (e) => {
            state.letterSpacing = parseInt(e.target.value);
        });

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (state.selectedIds.length > 0) {
                saveToHistory();
                state.elements = state.elements.filter(el => !state.selectedIds.includes(el.id));
                state.selectedIds = [];
                updateSelectionTools();
                renderElements();
            }
        });

        document.getElementById('alignBtn').addEventListener('click', () => {
            const letters = state.elements.filter(el => 
                state.selectedIds.includes(el.id) && el.type === 'letter'
            ).sort((a, b) => a.x - b.x);

            if (letters.length < 2) return;

            saveToHistory();
            const anchor = letters[0];
            let currentX = anchor.x;

            for (let i = 0; i < letters.length; i++) {
                letters[i].y = anchor.y;
                letters[i].fontSize = anchor.fontSize;
                if (i > 0) {
                    currentX += letters[i-1].width + state.letterSpacing;
                    letters[i].x = currentX;
                }
            }
            renderElements();
        });

        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            const scale = parseInt(e.target.value) / 100;
            const newSize = 48 * scale;

            for (const id of state.selectedIds) {
                const el = state.elements.find(el => el.id === id);
                if (el && el.type === 'letter') {
                    el.fontSize = newSize;
                    el.width = newSize * 0.7;
                }
            }
            renderElements();
        });

        document.getElementById('sizeSlider').addEventListener('change', saveToHistory);

        document.getElementById('saveBtn').addEventListener('click', () => {
            localStorage.setItem('whiteboard-template', JSON.stringify(state.elements));
            showToast(t('saved'));
        });

        document.getElementById('keyboardToggle').addEventListener('click', () => {
            state.keyboardVisible = !state.keyboardVisible;
            keyboard.classList.toggle('hidden', !state.keyboardVisible);
            document.getElementById('keyboardToggleText').textContent = 
                state.keyboardVisible ? t('hide') : t('show');
        });

        document.getElementById('langToggle').addEventListener('click', () => {
            currentLang = currentLang === 'mk' ? 'en' : 'mk';
            updateLanguage();
            renderKeyboard();
        });

        // Color palette
        const colors = ['#1e293b', '#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#ec4899'];
        const palette = document.getElementById('colorPalette');
        colors.forEach(color => {
            const btn = document.createElement('div');
            btn.className = 'color-btn';
            btn.style.backgroundColor = color;
            btn.addEventListener('click', () => {
                saveToHistory();
                for (const id of state.selectedIds) {
                    const el = state.elements.find(e => e.id === id);
                    if (el) el.color = color;
                }
                renderElements();
            });
            palette.appendChild(btn);
        });

        // ============ KEYBOARD SHORTCUTS ============
        document.addEventListener('keydown', (e) => {
            if (state.mode === 'typing') {
                handleTyping(e);
                return;
            }

            if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedIds.length > 0) {
                document.getElementById('deleteBtn').click();
            }

            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }

            if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // QWERTY to Cyrillic mapping
        const qwertyCyrillic = {
            'q': '—ô', 'w': '—ö', 'e': '–µ', 'r': '—Ä', 't': '—Ç', 'y': '—ï', 'u': '—É', 'i': '–∏', 'o': '–æ', 'p': '–ø',
            'a': '–∞', 's': '—Å', 'd': '–¥', 'f': '—Ñ', 'g': '–≥', 'h': '—Ö', 'j': '—ò', 'k': '–∫', 'l': '–ª',
            'z': '–∑', 'x': '—ü', 'c': '—Ü', 'v': '–≤', 'b': '–±', 'n': '–Ω', 'm': '–º',
            '[': '—à', ']': '—ì', ';': '—á', "'": '—ú'
        };

        function handleTyping(e) {
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            if (e.key === 'Escape') {
                setMode(null);
                return;
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                state.typingCursor.x = 100;
                state.typingCursor.y += state.typingCursor.fontSize * 1.5;
                renderElements();
                return;
            }

            let char = e.key;
            if (qwertyCyrillic[char.toLowerCase()]) {
                char = e.shiftKey ? qwertyCyrillic[char.toLowerCase()].toUpperCase() : qwertyCyrillic[char.toLowerCase()];
            }

            const isCyrillic = /[\u0400-\u04FF]/.test(char);
            const isPunct = /[0-9,.\?!;:\-\(\) ]/.test(char);
            
            if (!isCyrillic && !isPunct) return;
            
            e.preventDefault();

            const props = findNearestLetterProps(state.typingCursor.x, state.typingCursor.y);
            const fontSize = props.fontSize || state.typingCursor.fontSize;
            const width = fontSize * 0.7;

            saveToHistory();
            state.elements.push({
                id: generateId(),
                type: 'letter',
                content: char,
                x: state.typingCursor.x,
                y: state.typingCursor.y,
                fontSize,
                width,
                color: '#1e293b'
            });

            state.typingCursor.x += width + state.letterSpacing;
            state.typingCursor.fontSize = fontSize;
            renderElements();
        }

        // ============ IMAGE PASTE ============
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image();
                        img.onload = () => {
                            const maxW = 300;
                            const scale = img.width > maxW ? maxW / img.width : 1;
                            saveToHistory();
                            state.elements.push({
                                id: generateId(),
                                type: 'image',
                                content: ev.target.result,
                                x: 100,
                                y: 100,
                                width: img.width * scale,
                                height: img.height * scale
                            });
                            renderElements();
                        };
                        img.src = ev.target.result;
                    };
                    reader.readAsDataURL(file);
                    e.preventDefault();
                    break;
                }
            }
        });

        // ============ INIT ============
        function init() {
            const saved = localStorage.getItem('whiteboard-template');
            if (saved) {
                try {
                    state.elements = JSON.parse(saved);
                } catch (e) {}
            }

            updateLanguage();
            initKeyboard();
            renderElements();
            updateSelectionTools();
        }

        init();
    </script>
    <script src="home-button.js"></script>
</body>
</html>
