<!DOCTYPE html>
<html lang="mk">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WBACC Unified Studio</title>
    <style>
        :root {
            --primary: #667eea;
            --primary-grad: linear-gradient(90deg, #4c51bf 0%, #667eea 100%);
            --bg: #0f172a;
            --panel: #1e293b;
            --border: #334155;
            --text: #e2e8f0;
            --muted: #94a3b8;
            --success: #22c55e;
            --danger: #ef4444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: "Outfit", "Segoe UI", system-ui, sans-serif;
            overflow: hidden;
        }

        .top-nav {
            height: 66px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: rgba(15, 23, 42, 0.98);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 20;
        }

        .brand {
            font-weight: 800;
            letter-spacing: 0.02em;
            color: #c7d2fe;
            margin-right: 8px;
            white-space: nowrap;
        }

        .nav-tab {
            border: 1px solid transparent;
            background: #243247;
            color: var(--text);
            padding: 10px 16px;
            border-radius: 10px;
            font-weight: 700;
            cursor: pointer;
            transition: 0.2s ease;
        }

        .nav-tab:hover {
            border-color: #475569;
            transform: translateY(-1px);
        }

        .nav-tab.active {
            background: var(--primary-grad);
            color: white;
        }

        .workspace {
            height: calc(100vh - 66px);
            position: relative;
        }

        .panel {
            display: none;
            width: 100%;
            height: 100%;
        }

        .panel.active {
            display: block;
        }

        iframe.app-frame {
            width: 100%;
            height: 100%;
            border: 0;
            display: block;
            background: white;
        }

        .generator-wrap {
            height: 100%;
            overflow: auto;
            padding: 24px;
            background: radial-gradient(circle at 10% 10%, #1d4ed8 0%, #0f172a 48%, #020617 100%);
        }

        .generator-card {
            max-width: 980px;
            margin: 0 auto;
            background: rgba(15, 23, 42, 0.84);
            border: 1px solid var(--border);
            border-radius: 18px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
            padding: 24px;
            backdrop-filter: blur(4px);
        }

        .generator-title {
            font-size: 1.45rem;
            font-weight: 800;
            margin-bottom: 6px;
        }

        .generator-sub {
            color: var(--muted);
            margin-bottom: 18px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            margin-bottom: 14px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 7px;
        }

        .field.full {
            grid-column: 1 / -1;
        }

        label {
            font-size: 0.94rem;
            font-weight: 700;
        }

        select,
        textarea,
        input[type="file"] {
            width: 100%;
            border-radius: 10px;
            border: 1px solid #475569;
            background: #0b1220;
            color: var(--text);
            font-size: 0.95rem;
            padding: 10px 12px;
            font-family: inherit;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
            line-height: 1.35;
        }

        .btn-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 14px;
        }

        .btn {
            border: none;
            border-radius: 10px;
            padding: 10px 14px;
            font-weight: 700;
            cursor: pointer;
        }

        .btn-primary {
            background: var(--primary-grad);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-muted {
            background: #334155;
            color: #f8fafc;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .preview {
            min-height: 420px;
            border: 1px dashed #475569;
            border-radius: 14px;
            display: grid;
            place-items: center;
            background: rgba(15, 23, 42, 0.35);
            color: var(--muted);
            text-align: center;
            padding: 16px;
        }

        .preview img {
            max-width: 100%;
            max-height: 62vh;
            border-radius: 12px;
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
        }

        .status {
            margin-top: 10px;
            min-height: 22px;
            color: #cbd5e1;
            font-size: 0.92rem;
        }

        .status.error {
            color: #fca5a5;
        }

        .status.ok {
            color: #86efac;
        }

        @media (max-width: 900px) {
            .form-grid {
                grid-template-columns: 1fr;
            }

            .top-nav {
                flex-wrap: wrap;
                height: auto;
                padding-bottom: 12px;
            }

            .workspace {
                height: calc(100vh - 112px);
            }
        }
    </style>
</head>
<body>
    <nav class="top-nav">
        <div class="brand">WBACC Studio</div>
        <button class="nav-tab active" data-target="card">🃏 Картички</button>
        <button class="nav-tab" data-target="whiteboard">📝 Кирилична Табла</button>
    </nav>

    <main class="workspace">
        <section class="panel active" id="panel-card">
            <iframe id="cardFrame" class="app-frame" title="Картички"></iframe>
        </section>

        <section class="panel" id="panel-whiteboard">
            <iframe id="whiteboardFrame" class="app-frame" title="Кирилична Табла"></iframe>
        </section>

    </main>

    <template id="cardTemplate">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Креирај картичка - AAC Card Creator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --primary-color: #667eea;
            --primary-gradient: linear-gradient(90deg, #4c51bf 0%, #667eea 100%);
            --bg-color: #1a202c;
            --card-bg: #2d3748;
            --text-main: #f7fafc;
            --text-muted: #a0aec0;
            --border-color: #4a5568;
            --input-bg: #1a202c;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --radius-lg: 16px;
            --font-family: 'Outfit', sans-serif;
        }

        body.light-mode {
            --bg-color: #f0f4f8;
            --card-bg: #ffffff;
            --text-main: #1a202c;
            --text-muted: #4a5568;
            --border-color: #e2e8f0;
            --input-bg: #f7fafc;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
        }

        .app-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 3rem;
            max-width: 1050px;
            width: 100%;
            align-items: start;
        }

        @media (max-width: 850px) {
            .app-container { grid-template-columns: 1fr; }
        }

        .panel {
            background: var(--card-bg);
            border-radius: var(--radius-lg);
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
        }

        .header-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .control-btn {
            background: var(--input-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-size: 1rem;
            font-weight: 700;
            font-family: inherit;
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .panel-header h1 {
            font-size: 1.8rem;
            font-style: italic;
            margin-bottom: 0.5rem;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .panel-header p {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .tab-btn {
            flex: 1;
            padding: 0.75rem 0.5rem;
            background: transparent;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            border-color: var(--primary-color);
            color: var(--text-main);
        }

        .tab-btn.active {
            background: var(--primary-gradient);
            border-color: transparent;
            color: white;
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Form */
        .form-group { margin-bottom: 1.25rem; }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-main);
        }

        input[type="text"], textarea, select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: inherit;
            font-size: 1rem;
            background: var(--input-bg);
            color: var(--text-main);
        }

        select {
            cursor: pointer;
        }

        textarea {
            min-height: 70px;
            resize: vertical;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        small {
            display: block;
            margin-top: 0.5rem;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* Buttons */
        .btn-primary {
            background: var(--primary-gradient);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            width: 100%;
            font-family: inherit;
            font-size: 1.1rem;
            font-weight: 700;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn-primary:hover { opacity: 0.9; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-secondary {
            background-color: var(--border-color);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-family: inherit;
            font-size: 1.1rem;
            font-weight: 700;
            border: none;
            cursor: pointer;
            margin-top: 1.5rem;
        }

        .btn-stop {
            background: #e53e3e;
            color: white;
            padding: 0.75rem;
            border-radius: 8px;
            width: 100%;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 700;
            border: none;
            cursor: pointer;
            margin-top: 0.5rem;
        }

        /* Drop Zone */
        .drop-zone {
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            padding: 2rem 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--input-bg);
            margin-bottom: 1rem;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.1);
        }

        .drop-zone-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .drop-zone-text {
            color: var(--text-muted);
            font-size: 0.95rem;
        }

        .drop-zone-text strong {
            color: var(--primary-color);
        }

        .drop-zone input[type="file"] {
            display: none;
        }

        /* Image Editor */
        .image-editor {
            display: none;
            margin-top: 1rem;
        }

        .image-editor.active {
            display: block;
        }

        .crop-container {
            position: relative;
            width: 100%;
            height: 250px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            cursor: move;
        }

        .crop-container img {
            position: absolute;
            max-width: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        .crop-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 3px solid white;
            border-radius: 12px;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .zoom-controls label {
            margin: 0;
            font-size: 0.9rem;
            min-width: 50px;
        }

        .zoom-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 3px;
            cursor: pointer;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .editor-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .editor-buttons button {
            flex: 1;
            padding: 0.75rem;
            border-radius: 8px;
            font-family: inherit;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }

        .btn-apply {
            background: var(--primary-gradient);
            color: white;
        }

        .btn-cancel {
            background: var(--border-color);
            color: white;
        }

        /* Emoji Grid */
        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: var(--input-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 1rem;
            min-height: 100px;
        }

        .emoji-item {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .emoji-item:hover {
            background: var(--card-bg);
            transform: scale(1.1);
        }

        .emoji-item.selected {
            background: rgba(102, 126, 234, 0.3);
            border-color: var(--primary-color);
        }

        .emoji-message {
            grid-column: 1 / -1;
            text-align: center;
            padding: 1rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Card Display */
        .display-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: transparent;
            box-shadow: none;
            padding: 0;
            border: none;
        }

        .aac-card {
            background: white;
            width: 400px;
            height: 400px;
            border: 8px solid #a8d4ff;
            border-radius: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: var(--shadow-lg);
            padding: 1.5rem;
            box-sizing: border-box;
            overflow: hidden;
        }

        @media (max-width: 500px) {
            .aac-card { width: 320px; height: 320px; }
        }

        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            gap: 0.5rem;
        }

        .symbol-display {
            font-size: 9rem;
            line-height: 1;
            flex-shrink: 0;
        }

        .image-display {
            width: 220px;
            height: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            overflow: hidden;
            border-radius: 12px;
        }

        .image-display img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .placeholder-icon {
            font-size: 6rem;
            opacity: 0.2;
        }

        .large-label {
            font-size: 3rem;
            font-weight: 800;
            color: #1a1a2e;
            line-height: 1.2;
            word-break: break-word;
            text-align: center;
            max-width: 100%;
            padding: 0 0.5rem;
        }

        /* Spinner */
        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(102, 126, 234, 0.2);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-info { text-align: center; }

        .timer {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-top: 0.5rem;
        }

        /* Color controls */
        .color-controls {
            margin: 1rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .color-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .color-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            min-width: 50px;
        }

        .color-picker {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-swatch:hover { transform: scale(1.15); }
        .color-swatch.active {
            border-color: white;
            box-shadow: 0 0 0 2px var(--primary-color);
        }

        .sync-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
            cursor: pointer;
        }

        .credit-watermark {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 10px;
            color: rgba(102, 126, 234, 0.4);
            font-weight: 500;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <main class="app-container">
        <section class="panel input-panel">
            <header class="panel-header">
                <div class="header-controls">
                    <button id="theme-toggle" class="control-btn" title="Toggle theme">🌙</button>
                    <button id="lang-toggle" class="control-btn" title="Change language">EN</button>
                </div>
                <h1 data-i18n="title">Креирај картичка</h1>
                <p data-i18n="subtitle">Создавај визуелни помагала за комуникација</p>
            </header>

            <div class="tabs">
                <button class="tab-btn active" data-tab="emoji">😀 Емоџи</button>
                <button class="tab-btn" data-tab="upload">🖼 Внеси Слика</button>
            </div>

            <!-- TAB: EMOJI -->
            <div id="tab-emoji" class="tab-content active">
                <div class="form-group">
                    <label data-i18n="search_symbol">Барај Симбол</label>
                    <input type="text" id="emoji-search" placeholder="Напиши за пребарување (пр. 'happy', 'dog')..." autocomplete="off">
                </div>

                <div id="emoji-grid" class="emoji-grid">
                    <p class="emoji-message">Почни да пишуваш за пребарување...</p>
                </div>

                <div class="form-group">
                    <label data-i18n="label_text">Текст за Етикета</label>
                    <input type="text" id="emoji-label" placeholder="пр. Куче">
                </div>

                <button class="btn-primary" id="emoji-update-btn">Ажурирај Картичка</button>
            </div>

            <!-- TAB: UPLOAD / DRAG & DROP -->
            <div id="tab-upload" class="tab-content">
                <div class="drop-zone" id="drop-zone">
                    <div class="drop-zone-icon">📷</div>
                    <div class="drop-zone-text">
                        <strong>Повлечи слика тука</strong><br>
                        или кликни за избери
                    </div>
                    <input type="file" id="file-input" accept="image/*">
                </div>
                <p class="emoji-message">Може и Ctrl + V за paste од clipboard.</p>

                <div class="image-editor" id="image-editor">
                    <div class="crop-container" id="crop-container">
                        <img id="crop-image" src="" alt="Crop preview">
                        <div class="crop-overlay"></div>
                    </div>
                    <div class="zoom-controls">
                        <label>🔍 Зум:</label>
                        <input type="range" class="zoom-slider" id="zoom-slider" min="100" max="300" value="100">
                    </div>
                    <div class="editor-buttons">
                        <button class="btn-cancel" id="cancel-crop">✕ Откажи</button>
                        <button class="btn-apply" id="apply-crop">✓ Примени</button>
                    </div>
                </div>

                <div class="form-group">
                    <label data-i18n="label_text">Текст за Етикета</label>
                    <input type="text" id="upload-label" placeholder="пр. Куче">
                </div>

                <button class="btn-primary" id="upload-update-btn">Ажурирај Картичка</button>
            </div>

        </section>

        <section class="display-panel">
            <div id="aac-card" class="aac-card">
                <div class="card-content">
                    <div id="card-visual" class="symbol-display">👋</div>
                    <div id="card-label" class="large-label">Здраво</div>
                </div>
            </div>

            <div class="color-controls">
                <div class="color-row">
                    <span class="color-label">Рамка:</span>
                    <div class="color-picker" id="border-color-picker">
                        <button class="color-swatch active" data-color="#a8d4ff" style="background:#a8d4ff"></button>
                        <button class="color-swatch" data-color="#000000" style="background:#000"></button>
                        <button class="color-swatch" data-color="#2563eb" style="background:#2563eb"></button>
                        <button class="color-swatch" data-color="#16a34a" style="background:#16a34a"></button>
                        <button class="color-swatch" data-color="#dc2626" style="background:#dc2626"></button>
                        <button class="color-swatch" data-color="#9333ea" style="background:#9333ea"></button>
                        <button class="color-swatch" data-color="#f59e0b" style="background:#f59e0b"></button>
                        <button class="color-swatch" data-color="#ec4899" style="background:#ec4899"></button>
                    </div>
                </div>
                <div class="color-row">
                    <span class="color-label">Текст:</span>
                    <div class="color-picker" id="font-color-picker">
                        <button class="color-swatch active" data-color="#1a1a2e" style="background:#1a1a2e"></button>
                        <button class="color-swatch" data-color="#000000" style="background:#000"></button>
                        <button class="color-swatch" data-color="#2563eb" style="background:#2563eb"></button>
                        <button class="color-swatch" data-color="#16a34a" style="background:#16a34a"></button>
                        <button class="color-swatch" data-color="#dc2626" style="background:#dc2626"></button>
                        <button class="color-swatch" data-color="#9333ea" style="background:#9333ea"></button>
                        <button class="color-swatch" data-color="#f59e0b" style="background:#f59e0b"></button>
                        <button class="color-swatch" data-color="#ec4899" style="background:#ec4899"></button>
                    </div>
                </div>
                <label class="sync-checkbox">
                    <input type="checkbox" id="sync-colors"> Синхронизирај бои
                </label>
            </div>

            <button id="download-btn" class="btn-secondary">Зачувај Картичка 📸</button>
            <button id="insert-whiteboard-btn" class="btn-secondary">Вметни во Табла ➜</button>
        </section>
    </main>

    <div class="credit-watermark">Created by Blagoj Nasev</div>

    <script>
    // ============ EMOJI DATABASE ============
    var EMOJI_DATA = [
        {e:"😀",n:"happy grinning smile"},{e:"😃",n:"happy smile excited"},{e:"😄",n:"happy laugh smile"},
        {e:"😁",n:"happy grin teeth"},{e:"😆",n:"laugh happy squint"},{e:"😅",n:"sweat smile nervous"},
        {e:"🤣",n:"rofl laugh rolling"},{e:"😂",n:"joy tears laugh cry"},{e:"🙂",n:"smile slight happy"},
        {e:"😊",n:"blush smile happy shy"},{e:"😇",n:"angel innocent halo"},{e:"🥰",n:"love hearts smile"},
        {e:"😍",n:"love heart eyes"},{e:"😘",n:"kiss love blow"},{e:"😋",n:"yum delicious tasty food"},
        {e:"😛",n:"tongue playful"},{e:"😜",n:"wink tongue crazy"},{e:"🤪",n:"crazy zany wild"},
        {e:"🤗",n:"hug hands open"},{e:"🤔",n:"think hmm wonder"},{e:"🤫",n:"quiet shush secret"},
        {e:"😐",n:"neutral face blank"},{e:"😏",n:"smirk sly"},{e:"😒",n:"unamused annoyed"},
        {e:"🙄",n:"eye roll annoyed"},{e:"😌",n:"relieved peaceful calm"},{e:"😔",n:"sad pensive down"},
        {e:"😪",n:"sleepy tired"},{e:"🤤",n:"drool hungry"},{e:"😴",n:"sleep zzz tired"},
        {e:"😷",n:"sick mask ill"},{e:"🤒",n:"sick fever ill"},{e:"🤕",n:"hurt bandage injured"},
        {e:"🤢",n:"sick nausea green"},{e:"🤮",n:"vomit throw up sick"},{e:"🤧",n:"sneeze sick tissue"},
        {e:"🥵",n:"hot warm sweat"},{e:"🥶",n:"cold freezing"},{e:"😵",n:"dizzy spiral"},
        {e:"🤯",n:"mind blown explode"},{e:"🥳",n:"party celebrate birthday"},{e:"😎",n:"cool sunglasses"},
        {e:"🤓",n:"nerd glasses smart"},{e:"😕",n:"confused unsure"},{e:"😟",n:"worried nervous"},
        {e:"🙁",n:"sad frown"},{e:"😮",n:"surprised wow open mouth"},{e:"😲",n:"astonished shocked"},
        {e:"😳",n:"flushed embarrassed"},{e:"🥺",n:"pleading eyes puppy"},{e:"😨",n:"fearful scared afraid"},
        {e:"😰",n:"anxious sweat worried"},{e:"😢",n:"cry tear sad"},{e:"😭",n:"cry sob tears"},
        {e:"😱",n:"scream fear"},{e:"😞",n:"disappointed sad"},{e:"😩",n:"weary tired"},
        {e:"😫",n:"tired exhausted"},{e:"🥱",n:"yawn tired sleepy"},{e:"😤",n:"triumph huff angry"},
        {e:"😡",n:"angry mad rage"},{e:"😠",n:"angry"},{e:"🤬",n:"curse angry swear"},
        {e:"👋",n:"wave hand hello hi bye"},{e:"🤚",n:"raised hand stop"},{e:"✋",n:"hand raised stop"},
        {e:"👌",n:"ok okay hand"},{e:"✌️",n:"peace victory hand"},{e:"🤞",n:"fingers crossed luck"},
        {e:"🤟",n:"love you hand"},{e:"🤘",n:"rock on hand"},{e:"👈",n:"point left"},
        {e:"👉",n:"point right"},{e:"👆",n:"point up"},{e:"👇",n:"point down"},
        {e:"👍",n:"thumbs up good yes like"},{e:"👎",n:"thumbs down bad no dislike"},{e:"👏",n:"clap hands applause"},
        {e:"🙌",n:"hands raised celebration"},{e:"🤝",n:"handshake deal"},{e:"🙏",n:"pray thanks please"},
        {e:"💪",n:"muscle strong flex"},{e:"👂",n:"ear listen hear"},{e:"👃",n:"nose smell"},
        {e:"🧠",n:"brain think"},{e:"👀",n:"eyes look see"},{e:"👅",n:"tongue taste"},
        {e:"👄",n:"mouth lips"},{e:"👶",n:"baby infant"},{e:"🧒",n:"child kid"},
        {e:"👦",n:"boy"},{e:"👧",n:"girl"},{e:"👨",n:"man"},{e:"👩",n:"woman"},
        {e:"👴",n:"old man grandfather grandpa"},{e:"👵",n:"old woman grandmother grandma"},
        {e:"👮",n:"police officer cop"},{e:"👷",n:"construction worker"},{e:"👩‍⚕️",n:"doctor health nurse"},
        {e:"👩‍🍳",n:"cook chef"},{e:"👩‍🎓",n:"student graduate"},{e:"👩‍🏫",n:"teacher"},
        {e:"🚶",n:"walk person walking"},{e:"🏃",n:"run person running"},{e:"💃",n:"dance woman dancing"},
        {e:"🧘",n:"yoga meditation"},{e:"🛀",n:"bath bathtub"},{e:"🛌",n:"sleep bed"},
        {e:"👪",n:"family"},{e:"🐶",n:"dog puppy"},{e:"🐕",n:"dog"},{e:"🐩",n:"poodle dog"},
        {e:"🐺",n:"wolf"},{e:"🦊",n:"fox"},{e:"🐱",n:"cat kitten"},{e:"🐈",n:"cat"},
        {e:"🦁",n:"lion"},{e:"🐯",n:"tiger"},{e:"🐴",n:"horse"},{e:"🦄",n:"unicorn"},
        {e:"🐮",n:"cow"},{e:"🐷",n:"pig"},{e:"🐑",n:"sheep"},{e:"🐐",n:"goat"},
        {e:"🐘",n:"elephant"},{e:"🐭",n:"mouse"},{e:"🐰",n:"rabbit bunny"},{e:"🐻",n:"bear"},
        {e:"🐼",n:"panda"},{e:"🐨",n:"koala"},{e:"🐔",n:"chicken"},{e:"🐧",n:"penguin"},
        {e:"🐦",n:"bird"},{e:"🦅",n:"eagle"},{e:"🦆",n:"duck"},{e:"🦉",n:"owl"},
        {e:"🐸",n:"frog"},{e:"🐢",n:"turtle"},{e:"🐍",n:"snake"},{e:"🐳",n:"whale"},
        {e:"🐬",n:"dolphin"},{e:"🐟",n:"fish"},{e:"🦈",n:"shark"},{e:"🐙",n:"octopus"},
        {e:"🦋",n:"butterfly"},{e:"🐛",n:"bug caterpillar"},{e:"🐜",n:"ant"},{e:"🐝",n:"bee honeybee"},
        {e:"🐞",n:"ladybug"},{e:"🍎",n:"apple red"},{e:"🍏",n:"apple green"},{e:"🍊",n:"orange"},
        {e:"🍋",n:"lemon"},{e:"🍌",n:"banana"},{e:"🍉",n:"watermelon"},{e:"🍇",n:"grapes"},
        {e:"🍓",n:"strawberry"},{e:"🍒",n:"cherries"},{e:"🍑",n:"peach"},{e:"🥭",n:"mango"},
        {e:"🍍",n:"pineapple"},{e:"🥝",n:"kiwi"},{e:"🍅",n:"tomato"},{e:"🥑",n:"avocado"},
        {e:"🥦",n:"broccoli"},{e:"🥕",n:"carrot"},{e:"🌽",n:"corn"},{e:"🥔",n:"potato"},
        {e:"🍞",n:"bread"},{e:"🧀",n:"cheese"},{e:"🥚",n:"egg"},{e:"🍳",n:"cooking egg"},
        {e:"🥞",n:"pancakes"},{e:"🥓",n:"bacon"},{e:"🍗",n:"chicken leg"},{e:"🍖",n:"meat bone"},
        {e:"🌭",n:"hot dog"},{e:"🍔",n:"hamburger burger"},{e:"🍟",n:"fries french fries"},
        {e:"🍕",n:"pizza"},{e:"🥪",n:"sandwich"},{e:"🌮",n:"taco"},{e:"🌯",n:"burrito"},
        {e:"🍝",n:"spaghetti pasta"},{e:"🍜",n:"noodles ramen"},{e:"🍲",n:"pot stew"},
        {e:"🍣",n:"sushi"},{e:"🍤",n:"shrimp"},{e:"🍚",n:"rice"},{e:"🍧",n:"shaved ice"},
        {e:"🍨",n:"ice cream"},{e:"🍦",n:"ice cream cone"},{e:"🎂",n:"birthday cake"},
        {e:"🍰",n:"cake"},{e:"🍭",n:"lollipop candy"},{e:"🍬",n:"candy"},{e:"🍫",n:"chocolate"},
        {e:"🍿",n:"popcorn"},{e:"🍩",n:"doughnut donut"},{e:"🍪",n:"cookie"},{e:"🥛",n:"milk glass"},
        {e:"🍼",n:"baby bottle"},{e:"☕",n:"coffee hot"},{e:"🍵",n:"tea"},{e:"🧃",n:"juice box"},
        {e:"🥤",n:"cup straw"},{e:"🍺",n:"beer"},{e:"🍷",n:"wine"},{e:"⚽",n:"soccer football"},
        {e:"🏀",n:"basketball"},{e:"🏈",n:"american football"},{e:"⚾",n:"baseball"},
        {e:"🎾",n:"tennis"},{e:"🏐",n:"volleyball"},{e:"🎱",n:"pool billiards"},
        {e:"🏓",n:"ping pong"},{e:"🎯",n:"target bullseye"},{e:"🎮",n:"video game controller"},
        {e:"🧩",n:"puzzle piece"},{e:"🧸",n:"teddy bear"},{e:"🎨",n:"art palette paint"},
        {e:"🎵",n:"musical note"},{e:"🎶",n:"musical notes"},{e:"🎤",n:"microphone"},
        {e:"🎧",n:"headphone"},{e:"🎹",n:"piano keyboard"},{e:"🎸",n:"guitar"},
        {e:"🥁",n:"drum"},{e:"📱",n:"mobile phone"},{e:"💻",n:"laptop computer"},
        {e:"📺",n:"television tv"},{e:"📷",n:"camera"},{e:"📚",n:"books reading"},
        {e:"📖",n:"open book read"},{e:"📝",n:"memo write note"},{e:"✏️",n:"pencil write"},
        {e:"🎒",n:"backpack school bag"},{e:"🏠",n:"house"},{e:"🏫",n:"school building"},
        {e:"🏥",n:"hospital"},{e:"🚗",n:"car automobile"},{e:"🚌",n:"bus"},{e:"🚲",n:"bicycle bike"},
        {e:"✈️",n:"airplane"},{e:"🚀",n:"rocket"},{e:"⭐",n:"star"},{e:"🌟",n:"glowing star"},
        {e:"✨",n:"sparkles"},{e:"🔥",n:"fire flame hot"},{e:"🌈",n:"rainbow"},
        {e:"☀️",n:"sun sunny"},{e:"🌙",n:"moon"},{e:"☁️",n:"cloud"},{e:"🌧️",n:"rain"},
        {e:"❄️",n:"snowflake"},{e:"💧",n:"water droplet"},{e:"🌊",n:"wave water ocean"},
        {e:"❤️",n:"red heart love"},{e:"🧡",n:"orange heart"},{e:"💛",n:"yellow heart"},
        {e:"💚",n:"green heart"},{e:"💙",n:"blue heart"},{e:"💜",n:"purple heart"},
        {e:"💔",n:"broken heart"},{e:"💕",n:"two hearts"},{e:"💯",n:"hundred points"},
        {e:"✅",n:"check mark"},{e:"❌",n:"cross mark wrong"},{e:"❓",n:"question mark"},
        {e:"❗",n:"exclamation mark"},{e:"🎉",n:"party popper"},{e:"🎊",n:"confetti"},
        {e:"🎁",n:"gift present"},{e:"🎈",n:"balloon"},{e:"🎄",n:"christmas tree"},
        {e:"🎃",n:"pumpkin halloween"},{e:"🔔",n:"bell notification"},{e:"⏰",n:"alarm clock time"}
    ];

    // ============ MAIN APP ============
    document.addEventListener('DOMContentLoaded', function() {
        var themeToggle = document.getElementById('theme-toggle');
        var langToggle = document.getElementById('lang-toggle');
        var tabBtns = document.querySelectorAll('.tab-btn');
        var emojiSearch = document.getElementById('emoji-search');
        var emojiGrid = document.getElementById('emoji-grid');
        var emojiLabel = document.getElementById('emoji-label');
        var emojiUpdateBtn = document.getElementById('emoji-update-btn');
        var uploadLabel = document.getElementById('upload-label');
        var uploadUpdateBtn = document.getElementById('upload-update-btn');
        var aacCard = document.getElementById('aac-card');
        var cardVisual = document.getElementById('card-visual');
        var cardLabel = document.getElementById('card-label');
        var downloadBtn = document.getElementById('download-btn');
        var insertWhiteboardBtn = document.getElementById('insert-whiteboard-btn');

        // Drop zone elements
        var dropZone = document.getElementById('drop-zone');
        var fileInput = document.getElementById('file-input');
        var imageEditor = document.getElementById('image-editor');
        var cropContainer = document.getElementById('crop-container');
        var cropImage = document.getElementById('crop-image');
        var zoomSlider = document.getElementById('zoom-slider');
        var cancelCrop = document.getElementById('cancel-crop');
        var applyCrop = document.getElementById('apply-crop');

        var selectedEmoji = '👋';
        var currentUploadDataUrl = '';
        var isDarkMode = true;
        var currentLang = 'mk';

        // Image cropper state
        var cropState = {
            img: null,
            scale: 1,
            x: 0,
            y: 0,
            isDragging: false,
            startX: 0,
            startY: 0
        };

        // Theme toggle
        themeToggle.addEventListener('click', function() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('light-mode', !isDarkMode);
            themeToggle.textContent = isDarkMode ? '☀️' : '🌙';
        });

        // Language toggle (simplified)
        langToggle.addEventListener('click', function() {
            currentLang = currentLang === 'mk' ? 'en' : 'mk';
            langToggle.textContent = currentLang === 'mk' ? 'EN' : 'MK';
        });

        // Set label function
        function setLabel(text) {
            cardLabel.textContent = text || 'Етикета';
            autoResizeLabel();
        }

        function autoResizeLabel() {
            var len = cardLabel.textContent.length;
            var fontSize = 3;
            if (len > 20) fontSize = 1.8;
            else if (len > 15) fontSize = 2.2;
            else if (len > 10) fontSize = 2.5;
            else if (len > 5) fontSize = 2.8;
            cardLabel.style.fontSize = fontSize + 'rem';
        }

        function applyImageToCard(dataUrl, labelText) {
            if (!dataUrl) return;
            cardVisual.className = 'image-display';
            cardVisual.innerHTML = '<img src="' + dataUrl + '" alt="Custom image">';
            setLabel(labelText);
        }

        // Tab switching
        tabBtns.forEach(function(btn) {
            btn.addEventListener('click', function() {
                tabBtns.forEach(function(b) { b.classList.remove('active'); });
                document.querySelectorAll('.tab-content').forEach(function(c) { c.classList.remove('active'); });
                btn.classList.add('active');
                document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
            });
        });

        // Color pickers
        var borderColorPicker = document.getElementById('border-color-picker');
        var fontColorPicker = document.getElementById('font-color-picker');
        var syncColors = document.getElementById('sync-colors');

        borderColorPicker.addEventListener('click', function(e) {
            if (e.target.classList.contains('color-swatch')) {
                borderColorPicker.querySelectorAll('.color-swatch').forEach(function(s) { s.classList.remove('active'); });
                e.target.classList.add('active');
                aacCard.style.borderColor = e.target.dataset.color;
                if (syncColors.checked) {
                    fontColorPicker.querySelectorAll('.color-swatch').forEach(function(s) {
                        s.classList.remove('active');
                        if (s.dataset.color === e.target.dataset.color) s.classList.add('active');
                    });
                    cardLabel.style.color = e.target.dataset.color;
                }
            }
        });

        fontColorPicker.addEventListener('click', function(e) {
            if (e.target.classList.contains('color-swatch')) {
                fontColorPicker.querySelectorAll('.color-swatch').forEach(function(s) { s.classList.remove('active'); });
                e.target.classList.add('active');
                cardLabel.style.color = e.target.dataset.color;
                if (syncColors.checked) {
                    borderColorPicker.querySelectorAll('.color-swatch').forEach(function(s) {
                        s.classList.remove('active');
                        if (s.dataset.color === e.target.dataset.color) s.classList.add('active');
                    });
                    aacCard.style.borderColor = e.target.dataset.color;
                }
            }
        });

        // ============ EMOJI SEARCH ============
        emojiSearch.addEventListener('input', function() {
            var query = emojiSearch.value.trim().toLowerCase();
            if (query.length < 2) {
                emojiGrid.innerHTML = '<p class="emoji-message">Напиши барем 2 букви...</p>';
                return;
            }

            var results = EMOJI_DATA.filter(function(item) {
                return item.n.toLowerCase().indexOf(query) !== -1;
            });

            emojiGrid.innerHTML = '';
            if (results.length > 0) {
                results.slice(0, 25).forEach(function(item) {
                    var btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'emoji-item';
                    btn.textContent = item.e;
                    btn.title = item.n;
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.emoji-item').forEach(function(i) { i.classList.remove('selected'); });
                        btn.classList.add('selected');
                        selectedEmoji = item.e;
                        emojiLabel.value = item.n.split(' ')[0];
                        cardVisual.className = 'symbol-display';
                        cardVisual.textContent = item.e;
                        setLabel(emojiLabel.value);
                    });
                    emojiGrid.appendChild(btn);
                });
            } else {
                emojiGrid.innerHTML = '<p class="emoji-message">Нема резултати</p>';
            }
        });

        emojiUpdateBtn.addEventListener('click', function() {
            currentUploadDataUrl = '';
            cardVisual.className = 'symbol-display';
            cardVisual.textContent = selectedEmoji;
            setLabel(emojiLabel.value);
        });

        // ============ DRAG & DROP / UPLOAD ============
        dropZone.addEventListener('click', function() {
            fileInput.click();
        });

        dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', function() {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            var files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                loadImageForCrop(files[0]);
            }
        });

        fileInput.addEventListener('change', function() {
            if (fileInput.files.length > 0) {
                loadImageForCrop(fileInput.files[0]);
            }
        });

        document.addEventListener('paste', function(e) {
            var items = e.clipboardData && e.clipboardData.items;
            if (!items || !items.length) return;
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.type && item.type.indexOf('image/') === 0) {
                    var blob = item.getAsFile();
                    if (blob) loadImageForCrop(blob);
                    e.preventDefault();
                    break;
                }
            }
        });

        function loadImageForCrop(file) {
            var reader = new FileReader();
            reader.onload = function(e) {
                cropImage.src = e.target.result;
                cropImage.onload = function() {
                    imageEditor.classList.add('active');
                    dropZone.style.display = 'none';
                    initCropper();
                };
            };
            reader.readAsDataURL(file);
        }

        function initCropper() {
            cropState.scale = 1;
            cropState.x = 0;
            cropState.y = 0;
            zoomSlider.value = 100;
            updateCropImage();
        }

        function updateCropImage() {
            var containerWidth = cropContainer.offsetWidth;
            var containerHeight = cropContainer.offsetHeight;
            var imgWidth = cropImage.naturalWidth;
            var imgHeight = cropImage.naturalHeight;

            // Calculate base scale to fit container
            var baseScale = Math.max(200 / imgWidth, 200 / imgHeight);
            var scale = baseScale * cropState.scale;

            var scaledWidth = imgWidth * scale;
            var scaledHeight = imgHeight * scale;

            cropImage.style.width = scaledWidth + 'px';
            cropImage.style.height = scaledHeight + 'px';

            // Center initially
            var centerX = (containerWidth - scaledWidth) / 2 + cropState.x;
            var centerY = (containerHeight - scaledHeight) / 2 + cropState.y;

            cropImage.style.left = centerX + 'px';
            cropImage.style.top = centerY + 'px';
        }

        zoomSlider.addEventListener('input', function() {
            cropState.scale = zoomSlider.value / 100;
            updateCropImage();
        });

        // Drag to position
        cropContainer.addEventListener('mousedown', function(e) {
            cropState.isDragging = true;
            cropState.startX = e.clientX - cropState.x;
            cropState.startY = e.clientY - cropState.y;
        });

        document.addEventListener('mousemove', function(e) {
            if (cropState.isDragging) {
                cropState.x = e.clientX - cropState.startX;
                cropState.y = e.clientY - cropState.startY;
                updateCropImage();
            }
        });

        document.addEventListener('mouseup', function() {
            cropState.isDragging = false;
        });

        // Touch support
        cropContainer.addEventListener('touchstart', function(e) {
            var touch = e.touches[0];
            cropState.isDragging = true;
            cropState.startX = touch.clientX - cropState.x;
            cropState.startY = touch.clientY - cropState.y;
        });

        document.addEventListener('touchmove', function(e) {
            if (cropState.isDragging) {
                var touch = e.touches[0];
                cropState.x = touch.clientX - cropState.startX;
                cropState.y = touch.clientY - cropState.startY;
                updateCropImage();
            }
        });

        document.addEventListener('touchend', function() {
            cropState.isDragging = false;
        });

        cancelCrop.addEventListener('click', function() {
            imageEditor.classList.remove('active');
            dropZone.style.display = 'block';
            fileInput.value = '';
        });

        applyCrop.addEventListener('click', function() {
            // Create cropped image
            var canvas = document.createElement('canvas');
            canvas.width = 220;
            canvas.height = 220;
            var ctx = canvas.getContext('2d');

            var containerRect = cropContainer.getBoundingClientRect();
            var overlaySize = 200;
            var overlayX = (containerRect.width - overlaySize) / 2;
            var overlayY = (containerRect.height - overlaySize) / 2;

            var imgRect = cropImage.getBoundingClientRect();
            var scaleX = cropImage.naturalWidth / imgRect.width;
            var scaleY = cropImage.naturalHeight / imgRect.height;

            var srcX = (overlayX - (imgRect.left - containerRect.left)) * scaleX;
            var srcY = (overlayY - (imgRect.top - containerRect.top)) * scaleY;
            var srcW = overlaySize * scaleX;
            var srcH = overlaySize * scaleY;

            ctx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, 220, 220);

            var croppedDataUrl = canvas.toDataURL('image/png');

            // Apply to card
            currentUploadDataUrl = croppedDataUrl;
            applyImageToCard(currentUploadDataUrl, uploadLabel.value);

            // Reset editor
            imageEditor.classList.remove('active');
            dropZone.style.display = 'block';
            fileInput.value = '';
        });

        uploadUpdateBtn.addEventListener('click', function() {
            if (imageEditor.classList.contains('active')) {
                applyCrop.click();
                return;
            }

            if (currentUploadDataUrl) {
                applyImageToCard(currentUploadDataUrl, uploadLabel.value);
                return;
            }

            setLabel(uploadLabel.value);
        });

        // ============ DOWNLOAD ============
        downloadBtn.addEventListener('click', function() {
            downloadBtn.textContent = '⏳ Зачувувам...';
            downloadBtn.disabled = true;

            html2canvas(aacCard, {
                scale: 3,
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#ffffff'
            }).then(function(canvas) {
                var link = document.createElement('a');
                var filename = cardLabel.textContent.replace(/[^a-zA-Zа-яА-Яа-шА-Ш0-9]/g, '_') || 'symbol';
                link.download = 'aac_' + filename + '.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                downloadBtn.textContent = 'Зачувај Картичка 📸';
                downloadBtn.disabled = false;
            }).catch(function(err) {
                console.error('Save error:', err);
                alert('Грешка при зачувување');
                downloadBtn.textContent = 'Зачувај Картичка 📸';
                downloadBtn.disabled = false;
            });
        });

        insertWhiteboardBtn.addEventListener('click', function() {
            insertWhiteboardBtn.textContent = '⏳ Подготвувам...';
            insertWhiteboardBtn.disabled = true;

            html2canvas(aacCard, {
                scale: 3,
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#ffffff'
            }).then(function(canvas) {
                window.parent.postMessage({
                    type: 'insert-generated-image',
                    url: canvas.toDataURL('image/png')
                }, '*');
                insertWhiteboardBtn.textContent = 'Вметни во Табла ➜';
                insertWhiteboardBtn.disabled = false;
            }).catch(function(err) {
                console.error('Insert error:', err);
                alert('Грешка при внес во табла');
                insertWhiteboardBtn.textContent = 'Вметни во Табла ➜';
                insertWhiteboardBtn.disabled = false;
            });
        });

        autoResizeLabel();
    });
    </script>
</body>
</html>

    </template>

    <template id="whiteboardTemplate">
<!DOCTYPE html>
<html lang="mk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Кирилична Табла</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #1e293b;
            --bg-darker: #0f172a;
            --bg-light: #334155;
            --bg-lighter: #475569;
            --text-light: #e2e8f0;
            --text-muted: #94a3b8;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #eab308;
            --purple: #a855f7;
            --pink: #ec4899;
            --canvas-bg: #e2e8f0;
            --grid-color: rgba(100, 116, 139, 0.15);
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-darker);
            color: var(--text-light);
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* ============ TOOLBAR ============ */
        .toolbar {
            background: var(--bg-darker);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid var(--bg-light);
            flex-shrink: 0;
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .toolbar-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-light);
            white-space: nowrap;
        }

        .toolbar-tabs {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
            padding: 0 6px;
            border-left: 1px solid var(--bg-light);
            border-right: 1px solid var(--bg-light);
        }

        .toolbar-tab {
            border: 1px solid var(--bg-light);
            background: #111827;
            color: var(--text-muted);
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .toolbar-tab:hover {
            color: var(--text-light);
            border-color: var(--bg-lighter);
        }

        .toolbar-tab.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .toolbar-hidden-by-tab {
            display: none !important;
        }

        .toolbar-scroll {
            display: flex;
            align-items: center;
            gap: 8px;
            overflow-x: auto;
            flex: 1;
            padding-bottom: 4px;
        }

        .toolbar-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .toolbar-scroll::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        .toolbar-scroll::-webkit-scrollbar-thumb {
            background: var(--bg-lighter);
            border-radius: 2px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--bg-light);
            flex-shrink: 0;
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .btn-icon {
            padding: 6px;
            min-width: 32px;
            min-height: 32px;
        }

        .btn-default {
            background: var(--bg-light);
            color: var(--text-light);
        }

        .btn-default:hover {
            background: var(--bg-lighter);
        }

        .btn-default:disabled {
            background: var(--bg-dark);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-purple {
            background: var(--purple);
            color: white;
        }

        .btn-purple:hover {
            background: #9333ea;
        }

        .btn.active {
            background: var(--primary);
            color: white;
        }

        .btn.active-green {
            background: var(--success);
            color: white;
        }

        .btn.active-rose {
            background: var(--danger);
            color: white;
        }

        /* Slider control */
        .slider-control {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-light);
            padding: 4px 10px;
            border-radius: 6px;
        }

        .slider-control label {
            font-size: 11px;
            color: var(--text-muted);
        }

        .slider-control input[type="range"] {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--bg-lighter);
            border-radius: 2px;
            cursor: pointer;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        .slider-control input[type="color"] {
            width: 24px;
            height: 20px;
            padding: 0;
            border: none;
            background: transparent;
            cursor: pointer;
        }

        .slider-control input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .slider-control input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .slider-control input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .wb-textbox {
            user-select: none;
            cursor: default;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .wb-textbox.active {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .wb-textbox.active.editing {
            outline: 2px solid #22c55e;
            outline-offset: 2px;
            user-select: text;
            cursor: text;
        }

        .wb-textbox.no-outline {
            border-color: transparent !important;
        }

        .wb-textbox.no-outline.active {
            border-color: transparent !important;
        }

        /* Color palette */
        .color-palette {
            display: flex;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-light);
            border-radius: 6px;
        }

        .color-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .color-btn:hover {
            transform: scale(1.2);
        }

        /* ============ MAIN CANVAS AREA ============ */
        .main-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            background: #cbd5e1;
        }

        .canvas {
            position: relative;
            width: 4000px;
            height: 3000px;
            background-color: var(--canvas-bg);
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .canvas.mode-drawing {
            cursor: crosshair;
        }

        .canvas.mode-painting {
            cursor: pointer;
        }

        .canvas.mode-typing {
            cursor: text;
        }

        /* ============ ELEMENTS ON CANVAS ============ */
        .element {
            position: absolute;
            user-select: none;
        }

        .element-letter {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: grab;
            transition: border-color 0.1s;
        }

        .element-letter:active {
            cursor: grabbing;
        }

        .element-letter.selected {
            border-color: var(--primary);
        }

        .element-image {
            padding: 4px;
            background: white;
            border: 2px solid transparent;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: grab;
        }

        .element-image:active {
            cursor: grabbing;
        }

        .element-image.selected {
            border-color: var(--primary);
        }

        .element-image img {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .image-slot-placeholder {
            width: 100%;
            height: 100%;
            border: 2px dashed var(--primary);
            border-radius: 4px;
            background: rgba(59, 130, 246, 0.08);
            color: #1e3a8a;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            padding: 8px;
            white-space: pre-line;
            pointer-events: none;
        }

        .element-card {
            background: #ffffff;
            border: 8px solid #a8d4ff;
            border-radius: 16px;
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.2);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: grab;
        }

        .element-card:active {
            cursor: grabbing;
        }

        .element-card.selected {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .card-image-wrap {
            flex: 1;
            min-height: 60px;
            border-radius: 8px;
            background: #f8fafc;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-image-wrap img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .card-label-text {
            font-size: 20px;
            font-weight: 700;
            line-height: 1.15;
            text-align: center;
            color: #1a1a2e;
            word-break: break-word;
        }

        .element-embed {
            background: #ffffff;
            border: 2px solid transparent;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.25);
            overflow: hidden;
        }

        .element-embed.selected {
            border-color: var(--primary);
        }

        .embed-placeholder {
            height: calc(100% - 30px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 8px;
            color: #334155;
            font-size: 12px;
            text-align: center;
            padding: 12px;
            background: repeating-linear-gradient(
                -45deg,
                #f8fafc,
                #f8fafc 10px,
                #eef2ff 10px,
                #eef2ff 20px
            );
        }

        .embed-header {
            height: 30px;
            padding: 0 10px;
            background: #0f172a;
            color: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: grab;
            user-select: none;
            font-size: 12px;
            font-weight: 600;
            gap: 8px;
        }

        .embed-header:active {
            cursor: grabbing;
        }

        .embed-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .embed-open-btn {
            border: none;
            border-radius: 4px;
            background: #334155;
            color: #f8fafc;
            font-size: 10px;
            font-weight: 700;
            padding: 3px 6px;
            cursor: pointer;
        }

        .embed-open-btn:hover {
            background: #475569;
        }

        .embed-frame {
            width: 100%;
            height: calc(100% - 30px);
            border: 0;
            background: #f8fafc;
            pointer-events: none;
        }

        .embed-resize-handle {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
        }

        .image-resize-handle {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border: 2px solid white;
            border-radius: 50%;
            cursor: nwse-resize;
        }

        .element-line {
            cursor: move;
            overflow: visible;
        }

        .element-line .line-bar {
            position: absolute;
            height: 3px;
            border-radius: 999px;
            background: var(--bg-dark);
            transform-origin: 0 50%;
            transition: height 0.1s;
        }

        .element-line:hover .line-bar,
        .element-line.selected .line-bar {
            height: 4px;
        }

        .line-arrowhead {
            position: absolute;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid currentColor;
            pointer-events: none;
            transform-origin: center center;
        }

        .line-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 50%;
            display: none;
        }

        .element-line.selected .line-handle {
            display: block;
        }

        .line-handle-start,
        .line-handle-end {
            cursor: grab;
            transform: translate(-50%, -50%);
        }

        /* Selection box */
        .selection-box {
            position: absolute;
            border: 2px solid var(--primary);
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        /* Drawing line preview */
        .drawing-line-preview {
            position: absolute;
            pointer-events: none;
            overflow: visible;
        }

        .drawing-line-preview-bar {
            position: absolute;
            height: 2px;
            background: var(--primary);
            border-radius: 999px;
            opacity: 0.85;
            transform-origin: 0 50%;
        }

        .drawing-line-preview-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            border-left: 9px solid var(--primary);
            opacity: 0.9;
            transform-origin: center center;
        }

        /* Typing cursor */
        .typing-cursor {
            position: absolute;
            width: 2px;
            background: var(--primary);
            animation: blink 1s infinite;
            pointer-events: none;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* ============ KEYBOARD ============ */
        .keyboard {
            position: absolute;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            user-select: none;
            z-index: 100;
        }

        .keyboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--bg-light);
            cursor: default;
        }

        .keyboard-header.draggable {
            cursor: grab;
        }

        .keyboard-header.draggable:active {
            cursor: grabbing;
        }

        .keyboard-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
        }

        .keyboard-controls {
            display: flex;
            gap: 6px;
        }

        .keyboard-controls .btn {
            min-height: 28px;
            padding: 4px 8px;
            font-size: 11px;
            line-height: 1;
        }

        .keyboard-layout-btn {
            min-width: 42px;
            font-weight: 700;
        }

        .keyboard-lock-btn {
            min-width: 78px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.02em;
        }

        .keyboard-body {
            padding: 10px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 4px;
        }

        .keyboard-row:last-child {
            margin-bottom: 0;
        }

        .key {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-light);
            color: var(--text-light);
            border-radius: 4px;
            cursor: grab;
            transition: background 0.15s;
            font-weight: 500;
        }

        .key:hover {
            background: var(--bg-lighter);
        }

        .key:active {
            cursor: grabbing;
        }

        .key-special {
            cursor: pointer;
        }

        .key-caps.active {
            background: var(--primary);
        }

        .keyboard-resize-handle {
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            opacity: 0.5;
            transition: opacity 0.15s;
        }

        .keyboard-resize-handle:hover {
            opacity: 1;
        }

        .ppt-viewer {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 720px;
            height: 430px;
            background: rgba(15, 23, 42, 0.98);
            border: 1px solid var(--bg-lighter);
            border-radius: 12px;
            box-shadow: 0 16px 40px rgba(2, 6, 23, 0.45);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 120;
            transition: width 0.3s, height 0.3s, border-radius 0.3s;
        }

        .ppt-viewer.minimized {
            width: 220px !important;
            height: 38px !important;
            border-radius: 8px;
            bottom: 12px;
            right: 12px;
            top: auto !important;
            left: auto !important;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(2, 6, 23, 0.6);
        }

        .ppt-viewer.minimized .ppt-viewer-controls,
        .ppt-viewer.minimized .ppt-viewer-frame,
        .ppt-viewer.minimized .ppt-viewer-tip,
        .ppt-viewer.minimized .ppt-viewer-resize {
            display: none !important;
        }

        .ppt-viewer.minimized .ppt-viewer-header {
            padding: 6px 10px;
            cursor: pointer;
        }

        .ppt-viewer.minimized .ppt-viewer-header-actions .btn:not(#pptViewerMaxBtn) {
            display: none;
        }

        .ppt-viewer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var(--bg-light);
            background: #0b1220;
            cursor: move;
            user-select: none;
            gap: 8px;
        }

        .ppt-viewer-title {
            font-size: 12px;
            font-weight: 700;
            color: #cbd5e1;
            letter-spacing: 0.02em;
        }

        .ppt-viewer-header-actions {
            display: flex;
            gap: 6px;
        }

        .ppt-viewer-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-bottom: 1px solid var(--bg-light);
            background: #0f172a;
        }

        .ppt-viewer-controls input[type="text"] {
            flex: 1;
            min-width: 150px;
            border: 1px solid var(--bg-lighter);
            border-radius: 6px;
            background: #020617;
            color: var(--text-light);
            padding: 6px 8px;
            font-size: 12px;
            outline: none;
        }

        .ppt-viewer-controls input[type="text"]:focus {
            border-color: var(--primary);
        }

        .ppt-auto-hide {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--text-muted);
            font-size: 11px;
            white-space: nowrap;
        }

        .ppt-auto-hide input {
            accent-color: var(--primary);
        }

        .ppt-viewer-frame {
            flex: 1;
            border: 0;
            width: 100%;
            background: #ffffff;
        }

        .ppt-viewer-tip {
            font-size: 11px;
            color: var(--text-muted);
            padding: 6px 10px 8px;
            background: #0f172a;
            border-top: 1px solid var(--bg-light);
        }

        .ppt-viewer-resize {
            position: absolute;
            width: 14px;
            height: 14px;
            right: 4px;
            bottom: 4px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            background: var(--primary);
            cursor: nwse-resize;
            opacity: 0.85;
        }

        .keyboard-resize-handle svg {
            width: 100%;
            height: 100%;
            fill: var(--text-muted);
        }

        /* ============ TOAST NOTIFICATION ============ */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-dark);
            color: var(--text-light);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show {
            opacity: 1;
        }

        /* ============ ICONS (SVG) ============ */
        .icon {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .icon-sm {
            width: 14px;
            height: 14px;
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-left">
                <span class="toolbar-title" data-i18n="title">Кирилична Табла</span>
                <button class="btn btn-default btn-icon" id="langToggle">EN</button>
            </div>

            <!-- All tools visible - no hidden tabs -->
            <div class="toolbar-scroll">
                <!-- UNDO/REDO -->
                <button class="btn btn-default btn-icon" id="undoBtn" disabled title="Врати (Ctrl+Z)">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
                </button>
                <button class="btn btn-default btn-icon" id="redoBtn" disabled title="Повтори (Ctrl+Y)">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg>
                </button>

                <div class="toolbar-divider"></div>

                <!-- DRAW TOOLS -->
                <button class="btn btn-default btn-icon" id="typeBtn" title="Пишување (T)">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M2.5 4v3h5v12h3V7h5V4h-13zm19 5h-9v3h3v7h3v-7h3V9z"/></svg>
                </button>
                <button class="btn btn-default btn-icon" id="paintBtn" title="Боење">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 00-1.41 0L9 12.25 11.75 15l8.96-8.96a.996.996 0 000-1.41z"/></svg>
                </button>
                <button class="btn btn-default btn-icon" id="lineBtn" title="Линија">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M4 11h16v2H4z"/></svg>
                </button>
                <button class="btn btn-default btn-icon" id="arrowToggleBtn" title="Стрелка">↗️</button>
                <input type="color" id="typingColorPicker" value="#1e293b" title="Боја на пишување" style="width:28px;height:28px;border:1px solid #475569;border-radius:4px;padding:0;cursor:pointer;flex-shrink:0;">

                <div class="toolbar-divider"></div>

                <!-- FONT SIZE -->
                <span style="font-size:11px;color:#94a3b8;flex-shrink:0;">A</span>
                <input type="range" id="sizeSlider" min="50" max="200" value="100" disabled title="Големина" style="width:60px;flex-shrink:0;">
                <span style="font-size:16px;color:#94a3b8;flex-shrink:0;">A</span>
                <input type="range" id="spacingSlider" min="0" max="80" value="0" title="Растојание" style="width:50px;flex-shrink:0;">

                <div class="toolbar-divider"></div>

                <!-- SELECTION TOOLS (appear when selected) -->
                <div class="toolbar-group" id="selectionTools" style="display:none;">
                    <div class="color-palette" id="colorPalette"></div>
                    <button class="btn btn-danger btn-icon" id="deleteBtn" title="Избриши (Del)">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                    </button>
                    <button class="btn btn-default btn-icon" id="alignBtn" disabled title="Порамни">
                        <svg class="icon" viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/></svg>
                    </button>
                    <button class="btn btn-default btn-icon" id="alignDefaultBtn" disabled title="↔ Default">↔️</button>
                    <button class="btn btn-default btn-icon" id="makeCardBtn" title="Картичка" disabled>🏷</button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- TEXTBOX CONTROLS -->
                <div class="toolbar-group" id="textBoxToolsGroup" style="gap:3px;">
                    <span style="font-size:9px;color:#64748b;flex-shrink:0;">Fill</span>
                    <input type="color" id="textBoxBgColor" value="#ffffff" title="Позадина" style="width:22px;height:22px;border:1px solid #475569;border-radius:3px;padding:0;cursor:pointer;">
                    <span style="font-size:9px;color:#64748b;flex-shrink:0;">Aa</span>
                    <input type="color" id="textBoxFontColor" value="#0f172a" title="Боја на текст" style="width:22px;height:22px;border:1px solid #475569;border-radius:3px;padding:0;cursor:pointer;">
                    <span style="font-size:9px;color:#64748b;flex-shrink:0;">⬜</span>
                    <input type="color" id="textBoxBorderColor" value="#3b82f6" title="Боја на рамка" style="width:22px;height:22px;border:1px solid #475569;border-radius:3px;padding:0;cursor:pointer;">
                    <input type="range" id="textBoxOpacity" min="0" max="100" value="98" title="Проѕирност" style="width:40px;flex-shrink:0;">
                    <label title="Рамка вкл/искл" style="display:flex;align-items:center;gap:1px;cursor:pointer;flex-shrink:0;">
                        <input type="checkbox" id="textBoxOutline" checked style="margin:0;">
                    </label>
                    <select id="textBoxFontSize" title="Големина на фонт" style="width:48px;height:22px;font-size:10px;background:#1e293b;color:#e2e8f0;border:1px solid #475569;border-radius:3px;padding:0 2px;">
                        <option value="16">16</option>
                        <option value="20">20</option>
                        <option value="24">24</option>
                        <option value="28">28</option>
                        <option value="32" selected>32</option>
                        <option value="40">40</option>
                        <option value="48">48</option>
                        <option value="64">64</option>
                    </select>
                </div>

                <div class="toolbar-divider"></div>

                <!-- INSERT -->
                <button class="btn btn-default btn-icon" id="pptBtn" title="Вчитај документ / URL">📎</button>
                <button class="btn btn-default btn-icon" id="pptToggleBtn" title="Viewer">🪟</button>
                <button class="btn btn-default btn-icon" id="pasteImageBtn" title="Paste слика (Ctrl+V)" style="font-size:14px;">📋</button>
                <button class="btn btn-default btn-icon" id="keyboardToggle" title="Тастатура" style="background:#7c3aed;color:white;">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z"/></svg>
                </button>
                <span id="keyboardToggleText" style="display:none;"></span>

                <div class="toolbar-divider"></div>

                <!-- SNAP -->
                <button class="btn btn-default btn-icon" id="snapBtn" title="Лепење" style="font-size:10px;">
                    🧲 <span id="snapStatus">ВКЛ</span>
                </button>

                <div class="toolbar-divider"></div>

                <!-- SAVE/EXPORT -->
                <button class="btn btn-success btn-icon" id="saveBtn" title="Зачувај">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>
                </button>
                <button class="btn btn-icon" id="exportPngBtn" title="Експорт PNG" style="background:#0ea5e9;color:white;">
                    <svg class="icon" viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
                </button>
            </div>
        </div>

        <!-- Main canvas area -->
        <div class="main-area">
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas" id="canvas"></div>
            </div>

            <!-- Keyboard -->
            <div class="keyboard" id="keyboard">
                <div class="keyboard-header" id="keyboardHeader">
                    <span class="keyboard-title"><span id="keyboardFlag">🇲🇰</span> <span id="keyboardTitleLabel" data-i18n="macedonianKeyboard">Македонска Тастатура</span></span>
                    <div class="keyboard-controls">
                        <button class="btn btn-default keyboard-layout-btn" id="keyboardLayoutBtn" title="MK / EN">MK</button>
                        <button class="btn btn-default keyboard-lock-btn" id="lockBtn" title="Заклучено">🔒</button>
                    </div>
                </div>
                <div class="keyboard-body" id="keyboardBody"></div>
                <div class="keyboard-resize-handle" id="keyboardResize">
                    <svg viewBox="0 0 24 24"><path d="M22 22H20V20H22V22ZM22 18H20V16H22V18ZM18 22H16V20H18V22ZM22 14H20V12H22V14ZM18 18H16V16H18V18ZM14 22H12V20H14V22Z"/></svg>
                </div>
            </div>

            <div class="ppt-viewer hidden" id="pptViewer">
                <div class="ppt-viewer-header" id="pptViewerHeader">
                    <span class="ppt-viewer-title">Document Viewer</span>
                    <div class="ppt-viewer-header-actions">
                        <button class="btn btn-default" id="pptViewerMinBtn" title="Минимизирај">_</button>
                        <button class="btn btn-default" id="pptViewerMaxBtn" title="Врати" style="display:none;">▢</button>
                        <button class="btn btn-danger" id="pptViewerCloseBtn" title="Затвори">✕</button>
                    </div>
                </div>
                <div class="ppt-viewer-controls">
                    <input type="text" id="pptLinkInput" placeholder="Линк: документ, слика, или веб страна...">
                    <button class="btn btn-default" id="pptLoadBtn">Вчитај</button>
                    <button class="btn btn-success" id="pptCaptureBtn">📸 Сними → Табла</button>
                </div>
                <iframe id="pptViewerFrame" class="ppt-viewer-frame" title="Document Viewer"></iframe>
                <div class="ppt-viewer-tip">Отвори документ, кликни 📸 Сними → Табла за директно сликање. Или: Win+Shift+S за screenshot, па Ctrl+V.</div>
                <div class="ppt-viewer-resize" id="pptViewerResize"></div>
            </div>
        </div>

        <!-- Mode indicator -->
        <div id="modeIndicator" style="
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            color: #e2e8f0;
            padding: 5px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 200;
            pointer-events: none;
            border: 1px solid var(--bg-lighter);
            display: none;
        "></div>

        <!-- Toast -->
        <div class="toast" id="toast"></div>
    </div>

    <script>
        // ============ TRANSLATIONS ============
        const i18n = {
            mk: {
                title: 'Кирилична Табла',
                snap: 'Лепење',
                on: 'ВКЛ',
                off: 'ИСКЛ',
                spacing: 'Растојание',
                hide: 'Сокриј',
                show: 'Покажи',
                macedonianKeyboard: 'Македонска Тастатура',
                englishKeyboard: 'Англиска Тастатура',
                saved: 'Зачувано!',
                caps: 'Големи'
            },
            en: {
                title: 'Cyrillic Whiteboard',
                snap: 'Snap',
                on: 'ON',
                off: 'OFF',
                spacing: 'Spacing',
                hide: 'Hide',
                show: 'Show',
                macedonianKeyboard: 'Macedonian Keyboard',
                englishKeyboard: 'English Keyboard',
                saved: 'Saved!',
                caps: 'Caps'
            }
        };

        let currentLang = 'mk';

        function t(key) {
            return i18n[currentLang][key] || key;
        }

        function updateLanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.textContent = t(key);
            });
            document.getElementById('snapStatus').textContent = state.autoSnap ? t('on') : t('off');
            document.getElementById('keyboardToggleText').textContent = state.keyboardVisible ? t('hide') : t('show');
            document.getElementById('langToggle').textContent = currentLang === 'mk' ? 'EN' : 'MK';
            updateKeyboardLayoutUI();
            updateKeyboardLockUI();
        }

        // ============ STATE ============
        const DEFAULT_LETTER_SPACING = 0;

        const state = {
            elements: [],
            selectedIds: [],
            history: { past: [], future: [] },
            mode: null, // 'drawing', 'painting', 'typing'
            autoSnap: true,
            letterSpacing: DEFAULT_LETTER_SPACING,
            keyboardVisible: true,
            keyboardLocked: true,
            keyboardLayout: 'mk',
            keyboardCaps: false,
            drawArrow: false,
            typingCursor: { x: 100, y: 100, fontSize: 48 },
            typingColor: '#1e293b'
        };

        const SNAP_THRESHOLD = 15;
        const NEIGHBOR_RADIUS = 150;

        const widthMeasureCanvas = document.createElement('canvas');
        const widthMeasureCtx = widthMeasureCanvas.getContext('2d');

        function getLetterWidth(letter, fontSize) {
            const char = letter === ' ' ? '\u00A0' : letter;
            const safeSize = fontSize || 48;
            widthMeasureCtx.font = safeSize + 'px system-ui, -apple-system, "Segoe UI", Roboto, sans-serif';
            const metrics = widthMeasureCtx.measureText(char);
            const advanceWidth = metrics.width || 0;
            return Math.max(safeSize * 0.15, Math.ceil(advanceWidth));
        }

        function getMinSpacing(fontSize) {
            return 0;
        }

        function normalizeSpacing(spacing, fontSize) {
            const safeSize = fontSize || 48;
            const minSpacing = getMinSpacing(safeSize);
            const maxSpacing = Math.round(safeSize * 0.8);
            if (!Number.isFinite(spacing)) return minSpacing;
            return Math.max(minSpacing, Math.min(maxSpacing, Math.round(spacing)));
        }

        function getContextFontSize() {
            const selectedLetter = state.elements.find(el => state.selectedIds.includes(el.id) && el.type === 'letter');
            return selectedLetter ? (selectedLetter.fontSize || 48) : (state.typingCursor.fontSize || 48);
        }

        function getEffectiveSpacing(baseSpacing, fontSize) {
            return normalizeSpacing(baseSpacing, fontSize || getContextFontSize());
        }

        function reflowLetterSequence(letters, spacing) {
            if (!letters || letters.length < 2) return;
            const safeSpacing = getEffectiveSpacing(spacing, letters[0].fontSize || 48);
            let currentX = letters[0].x;
            for (let i = 1; i < letters.length; i++) {
                currentX += letters[i - 1].width + safeSpacing;
                letters[i].x = currentX;
            }
        }

        function reflowSelectedLetters() {
            const selectedLetters = state.elements
                .filter(el => state.selectedIds.includes(el.id) && el.type === 'letter')
                .sort((a, b) => (a.y - b.y) || (a.x - b.x));

            if (selectedLetters.length < 2) return;

            const rows = [];
            for (const letter of selectedLetters) {
                const row = rows.find(r => Math.abs(r.anchorY - letter.y) <= Math.max(10, letter.fontSize * 0.35));
                if (row) {
                    row.items.push(letter);
                } else {
                    rows.push({ anchorY: letter.y, items: [letter] });
                }
            }

            for (const row of rows) {
                row.items.sort((a, b) => a.x - b.x);
                reflowLetterSequence(row.items, state.letterSpacing);
            }
        }

        function ensureLineShape(line) {
            if (!line || line.type !== 'line') return line;
            if (Number.isFinite(line.x1) && Number.isFinite(line.y1) && Number.isFinite(line.x2) && Number.isFinite(line.y2)) {
                return line;
            }

            const safeX = Number.isFinite(line.x) ? line.x : 0;
            const safeY = Number.isFinite(line.y) ? line.y : 0;
            const safeWidth = Number.isFinite(line.width) ? line.width : 60;
            line.x1 = safeX;
            line.y1 = safeY;
            line.x2 = safeX + safeWidth;
            line.y2 = safeY;
            return line;
        }

        function getLinePoints(line) {
            ensureLineShape(line);
            return {
                x1: line.x1,
                y1: line.y1,
                x2: line.x2,
                y2: line.y2
            };
        }

        function getLineBounds(line, padding = 0) {
            const { x1, y1, x2, y2 } = getLinePoints(line);
            const minX = Math.min(x1, x2) - padding;
            const minY = Math.min(y1, y2) - padding;
            const maxX = Math.max(x1, x2) + padding;
            const maxY = Math.max(y1, y2) + padding;
            return {
                x: minX,
                y: minY,
                width: Math.max(1, maxX - minX),
                height: Math.max(1, maxY - minY),
                minX,
                minY,
                maxX,
                maxY
            };
        }

        function getHorizontalLineBaseline(line) {
            const { x1, y1, x2, y2 } = getLinePoints(line);
            const dx = x2 - x1;
            const dy = y2 - y1;
            if (Math.abs(dx) < 20) return null;
            if (Math.abs(dy) > Math.max(6, Math.abs(dx) * 0.12)) return null;
            return {
                x1: Math.min(x1, x2),
                x2: Math.max(x1, x2),
                y: (y1 + y2) / 2
            };
        }

        function renderDrawingLinePreview(startX, startY, endX, endY, arrowEnd) {
            canvas.querySelectorAll('.drawing-line-preview').forEach(el => el.remove());

            const dx = endX - startX;
            const dy = endY - startY;
            const length = Math.hypot(dx, dy);
            if (length < 1) return;

            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            const padding = 10;
            const minX = Math.min(startX, endX);
            const minY = Math.min(startY, endY);

            const preview = document.createElement('div');
            preview.className = 'drawing-line-preview';
            preview.style.left = (minX - padding) + 'px';
            preview.style.top = (minY - padding) + 'px';
            preview.style.width = (Math.abs(dx) + padding * 2) + 'px';
            preview.style.height = (Math.abs(dy) + padding * 2) + 'px';

            const lineBar = document.createElement('div');
            lineBar.className = 'drawing-line-preview-bar';
            lineBar.style.left = (padding + startX - minX) + 'px';
            lineBar.style.top = (padding + startY - minY) + 'px';
            lineBar.style.width = Math.max(2, length - (arrowEnd ? 10 : 0)) + 'px';
            lineBar.style.transform = `translateY(-50%) rotate(${angle}deg)`;
            preview.appendChild(lineBar);

            if (arrowEnd) {
                const arrow = document.createElement('div');
                arrow.className = 'drawing-line-preview-arrow';
                arrow.style.left = (padding + endX - minX) + 'px';
                arrow.style.top = (padding + endY - minY) + 'px';
                arrow.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
                preview.appendChild(arrow);
            }

            canvas.appendChild(preview);
        }

        // ============ DOM ELEMENTS ============
        const canvas = document.getElementById('canvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const keyboard = document.getElementById('keyboard');
        const keyboardBody = document.getElementById('keyboardBody');
        const keyboardHeader = document.getElementById('keyboardHeader');
        const keyboardLayoutBtn = document.getElementById('keyboardLayoutBtn');
        const lockBtn = document.getElementById('lockBtn');
        const keyboardFlag = document.getElementById('keyboardFlag');
        const keyboardTitleLabel = document.getElementById('keyboardTitleLabel');
        const toast = document.getElementById('toast');
        const pptViewer = document.getElementById('pptViewer');
        const pptViewerHeader = document.getElementById('pptViewerHeader');
        const pptViewerFrame = document.getElementById('pptViewerFrame');
        const pptViewerResize = document.getElementById('pptViewerResize');
        const pptLinkInput = document.getElementById('pptLinkInput');
        const pptAutoHide = document.getElementById('pptAutoHide');
        const toolbarTabs = Array.from(document.querySelectorAll('[data-toolbar-tab]'));
        const toolbarTabGroups = Array.from(document.querySelectorAll('[data-toolbar-group]'));
        let activeToolbarTab = 'home';

        // ============ UTILITY FUNCTIONS ============
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        const pptSession = {
            sourceUrl: '',
            embedUrl: '',
            captureArmed: false,
            captureSlotId: ''
        };

        function saveToHistory() {
            state.history.past.push(JSON.stringify(state.elements));
            if (state.history.past.length > 20) state.history.past.shift();
            state.history.future = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.history.past.length === 0) return;
            state.history.future.push(JSON.stringify(state.elements));
            state.elements = JSON.parse(state.history.past.pop());
            state.selectedIds = [];
            renderElements();
            updateUndoRedoButtons();
            updateSelectionTools();
        }

        function redo() {
            if (state.history.future.length === 0) return;
            state.history.past.push(JSON.stringify(state.elements));
            state.elements = JSON.parse(state.history.future.pop());
            state.selectedIds = [];
            renderElements();
            updateUndoRedoButtons();
            updateSelectionTools();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = state.history.past.length === 0;
            document.getElementById('redoBtn').disabled = state.history.future.length === 0;
        }

        function updateKeyboardLayoutUI() {
            if (!keyboardLayoutBtn || !keyboardTitleLabel || !keyboardFlag) return;
            const mkLayout = state.keyboardLayout === 'mk';
            keyboardLayoutBtn.textContent = mkLayout ? 'MK' : 'EN';
            keyboardLayoutBtn.classList.toggle('active', !mkLayout);
            keyboardFlag.textContent = mkLayout ? '🇲🇰' : '🇬🇧';
            keyboardTitleLabel.textContent = mkLayout ? t('macedonianKeyboard') : t('englishKeyboard');
        }

        function updateKeyboardLockUI() {
            if (!lockBtn || !keyboardHeader) return;
            const locked = !!state.keyboardLocked;
            lockBtn.textContent = locked ? '🔒 LOCK' : '🔓 MOVE';
            lockBtn.title = locked ? 'Заклучено (drag off)' : 'Отклучено (drag on)';
            lockBtn.setAttribute('aria-pressed', locked ? 'true' : 'false');
            lockBtn.classList.toggle('active-rose', locked);
            lockBtn.classList.toggle('active-green', !locked);
            keyboardHeader.classList.toggle('draggable', !locked);
        }

        function applyToolbarTab(target) {
            // No-op: all tools are now always visible (Word-style ribbon)
            updateSelectionTools();
        }

        function updateSelectionTools() {
            const selectionTools = document.getElementById('selectionTools');
            const alignBtn = document.getElementById('alignBtn');
            const alignDefaultBtn = document.getElementById('alignDefaultBtn');
            const sizeSlider = document.getElementById('sizeSlider');
            const makeCardBtn = document.getElementById('makeCardBtn');

            const selectedLetters = state.elements.filter(el =>
                state.selectedIds.includes(el.id) && el.type === 'letter'
            );
            const selectedVisual = state.elements.filter(el =>
                state.selectedIds.includes(el.id) && (el.type === 'image' || el.type === 'card')
            );

            if (state.selectedIds.length > 0) {
                selectionTools.style.display = 'flex';

                const canAlign = selectedLetters.length >= 2;
                alignBtn.disabled = !canAlign;
                if (alignDefaultBtn) alignDefaultBtn.disabled = !canAlign;
                sizeSlider.disabled = selectedLetters.length === 0;
                if (makeCardBtn) makeCardBtn.disabled = selectedVisual.length !== 1;

                if (selectedLetters.length > 0) {
                    const scale = (selectedLetters[0].fontSize / 48) * 100;
                    sizeSlider.value = scale;
                }
            } else {
                selectionTools.style.display = 'none';
                alignBtn.disabled = true;
                if (alignDefaultBtn) alignDefaultBtn.disabled = true;
                sizeSlider.disabled = true;
                sizeSlider.value = 100;
                if (makeCardBtn) makeCardBtn.disabled = true;
            }
        }
        // ============ FIND NEAREST LETTER PROPERTIES ============
        function findNearestLetterProps(x, y) {
            const letters = state.elements.filter(el => el.type === 'letter');
            if (letters.length === 0) {
                const fallbackSize = state.typingCursor.fontSize || 48;
                return { fontSize: fallbackSize, spacing: getEffectiveSpacing(state.letterSpacing, fallbackSize) };
            }

            let nearest = null;
            let minDist = Infinity;

            for (const letter of letters) {
                const cx = letter.x + letter.width / 2;
                const cy = letter.y + letter.fontSize / 2;
                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                if (dist < NEIGHBOR_RADIUS && dist < minDist) {
                    minDist = dist;
                    nearest = letter;
                }
            }

            if (!nearest) {
                const fallbackSize = state.typingCursor.fontSize || 48;
                return { fontSize: fallbackSize, spacing: getEffectiveSpacing(state.letterSpacing, fallbackSize) };
            }

            const sameLineThreshold = Math.max(10, nearest.fontSize * 0.35);
            const sameLine = letters
                .filter(l => Math.abs(l.y - nearest.y) < sameLineThreshold)
                .sort((a, b) => a.x - b.x);

            let detectedSpacing = getEffectiveSpacing(state.letterSpacing, nearest.fontSize);

            if (sameLine.length >= 2) {
                let totalGap = 0;
                let count = 0;

                for (let i = 1; i < sameLine.length; i++) {
                    const gap = sameLine[i].x - (sameLine[i - 1].x + sameLine[i - 1].width);
                    if (gap > -2 && gap < nearest.fontSize * 1.2) {
                        totalGap += gap;
                        count++;
                    }
                }

                if (count > 0) {
                    detectedSpacing = getEffectiveSpacing(totalGap / count, nearest.fontSize);
                }
            }

            return {
                fontSize: nearest.fontSize,
                spacing: detectedSpacing,
                color: nearest.color,
                nearest
            };
        }

        // ============ RENDER ELEMENTS ============
        function renderElements() {
            // Clear canvas except for dynamic elements
            canvas.querySelectorAll('.element').forEach(el => el.remove());
            canvas.querySelectorAll('.selection-box').forEach(el => el.remove());
            canvas.querySelectorAll('.drawing-line-preview').forEach(el => el.remove());
            canvas.querySelectorAll('.typing-cursor').forEach(el => el.remove());

            for (const el of state.elements) {
                const dom = createElementDOM(el);
                canvas.appendChild(dom);
            }

            // Render typing cursor if in typing mode
            if (state.mode === 'typing') {
                const cursor = document.createElement('div');
                cursor.className = 'typing-cursor';
                cursor.style.left = state.typingCursor.x + 'px';
                cursor.style.top = state.typingCursor.y + 'px';
                cursor.style.height = (state.typingCursor.fontSize * 1.2) + 'px';
                canvas.appendChild(cursor);
            }
        }

        function createElementDOM(el) {
            if (el.type === 'letter') {
                const div = document.createElement('div');
                div.className = 'element element-letter' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = (el.width || getLetterWidth(el.content, el.fontSize)) + 'px';
                div.style.height = Math.ceil(el.fontSize * 1.2) + 'px';
                div.style.fontSize = el.fontSize + 'px';
                div.style.color = el.color || '#1e293b';
                div.textContent = el.content === ' ' ? '\u00A0' : el.content;
                
                setupLetterDrag(div, el);
                return div;
            }

            if (el.type === 'line') {
                ensureLineShape(el);
                const { x1, y1, x2, y2 } = getLinePoints(el);
                const bounds = getLineBounds(el, 10);
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.max(1, Math.hypot(dx, dy));
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);

                const div = document.createElement('div');
                div.className = 'element element-line' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = bounds.x + 'px';
                div.style.top = bounds.y + 'px';
                div.style.width = bounds.width + 'px';
                div.style.height = bounds.height + 'px';
                
                const bar = document.createElement('div');
                bar.className = 'line-bar';
                bar.style.backgroundColor = el.color || '#1e293b';
                bar.style.left = (x1 - bounds.x) + 'px';
                bar.style.top = (y1 - bounds.y) + 'px';
                bar.style.width = Math.max(2, length - (el.arrowEnd ? 10 : 0)) + 'px';
                bar.style.transform = `translateY(-50%) rotate(${angle}deg)`;
                div.appendChild(bar);

                if (el.arrowEnd) {
                    const arrowHead = document.createElement('div');
                    arrowHead.className = 'line-arrowhead';
                    arrowHead.style.color = el.color || '#1e293b';
                    arrowHead.style.left = (x2 - bounds.x) + 'px';
                    arrowHead.style.top = (y2 - bounds.y) + 'px';
                    arrowHead.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
                    div.appendChild(arrowHead);
                }

                const startHandle = document.createElement('div');
                startHandle.className = 'line-handle line-handle-start';
                startHandle.style.left = (x1 - bounds.x) + 'px';
                startHandle.style.top = (y1 - bounds.y) + 'px';
                div.appendChild(startHandle);

                const endHandle = document.createElement('div');
                endHandle.className = 'line-handle line-handle-end';
                endHandle.style.left = (x2 - bounds.x) + 'px';
                endHandle.style.top = (y2 - bounds.y) + 'px';
                div.appendChild(endHandle);

                setupLineDrag(div, el, startHandle, endHandle);
                return div;
            }

            if (el.type === 'image') {
                const div = document.createElement('div');
                div.className = 'element element-image' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = el.width + 'px';
                div.style.height = el.height + 'px';

                if (el.content) {
                    const img = document.createElement('img');
                    img.src = el.content;
                    div.appendChild(img);
                } else {
                    const slot = document.createElement('div');
                    slot.className = 'image-slot-placeholder';
                    slot.textContent = el.slotType === 'ppt-capture'
                        ? 'Doc Screenshot Slot\nWin+Shift+S, then Ctrl+V'
                        : 'Image Slot\nDrop or paste image';
                    div.appendChild(slot);
                }

                if (state.selectedIds.includes(el.id)) {
                    const handle = document.createElement('div');
                    handle.className = 'image-resize-handle';
                    div.appendChild(handle);
                    setupImageResize(handle, el);
                }

                setupImageDrag(div, el);
                return div;
            }

            if (el.type === 'card') {
                const div = document.createElement('div');
                div.className = 'element element-card' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = el.width + 'px';
                div.style.height = el.height + 'px';
                div.style.borderColor = el.borderColor || '#a8d4ff';

                const imageWrap = document.createElement('div');
                imageWrap.className = 'card-image-wrap';
                if (el.content) {
                    const img = document.createElement('img');
                    img.src = el.content;
                    imageWrap.appendChild(img);
                } else {
                    imageWrap.textContent = 'No image';
                }

                const label = document.createElement('div');
                label.className = 'card-label-text';
                label.style.color = el.textColor || '#1a1a2e';
                label.textContent = el.label || 'Етикета';

                div.appendChild(imageWrap);
                div.appendChild(label);

                if (state.selectedIds.includes(el.id)) {
                    const handle = document.createElement('div');
                    handle.className = 'image-resize-handle';
                    div.appendChild(handle);
                    setupImageResize(handle, el);
                }

                setupImageDrag(div, el);
                return div;
            }

            if (el.type === 'embed') {
                const div = document.createElement('div');
                div.className = 'element element-embed' + (state.selectedIds.includes(el.id) ? ' selected' : '');
                div.dataset.id = el.id;
                div.style.left = el.x + 'px';
                div.style.top = el.y + 'px';
                div.style.width = el.width + 'px';
                div.style.height = el.height + 'px';

                const header = document.createElement('div');
                header.className = 'embed-header';

                const title = document.createElement('span');
                title.className = 'embed-title';
                title.textContent = el.title || 'Document';
                header.appendChild(title);

                const openBtn = document.createElement('button');
                openBtn.type = 'button';
                openBtn.className = 'embed-open-btn';
                openBtn.textContent = 'Open';
                openBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    window.open(el.sourceUrl || el.content, '_blank', 'noopener,noreferrer');
                });
                header.appendChild(openBtn);

                const placeholder = document.createElement('div');
                placeholder.className = 'embed-placeholder';
                placeholder.innerHTML = '<strong>Document Preview</strong><span>Use the floating viewer window for navigation and capture.</span>';

                div.appendChild(header);
                div.appendChild(placeholder);

                if (state.selectedIds.includes(el.id)) {
                    const handle = document.createElement('div');
                    handle.className = 'embed-resize-handle';
                    div.appendChild(handle);
                    setupEmbedResize(handle, el);
                }

                setupEmbedDrag(div, header, el);
                return div;
            }

            return document.createElement('div');
        }

        // ============ DRAG HANDLERS ============
        function setupLetterDrag(dom, el) {
            let startX, startY;
            let dragging = false;
            let moved = false;
            const selectedOrigins = new Map();

            dom.addEventListener('mousedown', (e) => {
                if (state.mode === 'drawing') return;
                e.stopPropagation();

                if (state.mode === 'painting') {
                    saveToHistory();
                    el.color = '#ef4444';
                    renderElements();
                    return;
                }

                // Exit typing mode when clicking a letter to select it
                if (state.mode === 'typing') {
                    setMode(null);
                }

                if (e.shiftKey) {
                    if (state.selectedIds.includes(el.id)) {
                        state.selectedIds = state.selectedIds.filter(id => id !== el.id);
                    } else {
                        state.selectedIds.push(el.id);
                    }
                } else if (!state.selectedIds.includes(el.id)) {
                    state.selectedIds = [el.id];
                }

                updateSelectionTools();
                renderElements();

                dragging = true;
                moved = false;
                startX = e.clientX;
                startY = e.clientY;
                selectedOrigins.clear();

                for (const id of state.selectedIds) {
                    const sel = state.elements.find(s => s.id === id);
                    if (sel && typeof sel.x === 'number' && typeof sel.y === 'number') {
                        selectedOrigins.set(id, { x: sel.x, y: sel.y });
                    }
                }

                if (!selectedOrigins.has(el.id)) {
                    selectedOrigins.set(el.id, { x: el.x, y: el.y });
                }

                const onMove = (moveEvent) => {
                    if (!dragging) return;
                    const dx = moveEvent.clientX - startX;
                    const dy = moveEvent.clientY - startY;
                    if (Math.abs(dx) > 1 || Math.abs(dy) > 1) moved = true;

                    for (const [id, origin] of selectedOrigins.entries()) {
                        const target = state.elements.find(s => s.id === id);
                        if (target && typeof target.x === 'number' && typeof target.y === 'number') {
                            target.x = origin.x + dx;
                            target.y = origin.y + dy;
                        }
                    }
                    renderElements();
                };

                const onUp = () => {
                    if (dragging && moved) {
                        dragging = false;
                        saveToHistory();

                        if (state.autoSnap) {
                            const selectedLetters = state.elements.filter(item =>
                                state.selectedIds.includes(item.id) && item.type === 'letter'
                            );
                            for (const letter of selectedLetters) {
                                snapElement(letter);
                            }
                            renderElements();
                        }
                    } else {
                        dragging = false;
                    }

                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
        function snapElement(el) {
            if (el.type !== 'letter') return;

            const lines = state.elements.filter(e => e.type === 'line');
            const letters = state.elements.filter(e => e.type === 'letter' && e.id !== el.id);

            // Snap to line (Y)
            const descenders = new Set(['ј', 'р', 'у', 'ф', 'ц', 'ш', 'ѕ', 'ѓ', 'ќ']);
            const hasDescender = descenders.has(el.content.toLowerCase());
            const baselineRatio = hasDescender ? 0.8 : 1.0;
            const height = el.fontSize * 1.2;
            const baselinePos = height * baselineRatio;

            for (const line of lines) {
                const baseline = getHorizontalLineBaseline(line);
                if (!baseline) continue;

                if (el.x + el.width > baseline.x1 && el.x < baseline.x2) {
                    const elBaseline = el.y + baselinePos;
                    if (Math.abs(elBaseline - baseline.y) < SNAP_THRESHOLD) {
                        el.y = baseline.y - baselinePos;
                        break;
                    }
                }
            }

            // Snap to letter (X)
            for (const other of letters) {
                const safeSpacing = getEffectiveSpacing(state.letterSpacing, Math.min(el.fontSize, other.fontSize || el.fontSize));
                const snapX = other.x + other.width + safeSpacing;
                if (Math.abs(el.x - snapX) < SNAP_THRESHOLD) {
                    el.x = snapX;
                    break;
                }
            }
        }

        function setupLineDrag(dom, el, startHandle, endHandle) {
            const beginSelect = (e) => {
                if (state.mode === 'drawing') return false;
                if (e.shiftKey) {
                    if (state.selectedIds.includes(el.id)) {
                        state.selectedIds = state.selectedIds.filter(id => id !== el.id);
                    } else {
                        state.selectedIds.push(el.id);
                    }
                } else {
                    state.selectedIds = [el.id];
                }
                updateSelectionTools();
                renderElements();
                return true;
            };

            dom.addEventListener('mousedown', (e) => {
                if (state.mode === 'drawing') return;
                if (e.target === startHandle || e.target === endHandle) return;
                e.stopPropagation();
                if (!beginSelect(e)) return;

                ensureLineShape(el);
                const initial = getLinePoints(el);
                const startX = e.clientX;
                const startY = e.clientY;
                let moved = false;

                const onMove = (moveEvent) => {
                    const dx = moveEvent.clientX - startX;
                    const dy = moveEvent.clientY - startY;
                    moved = moved || Math.abs(dx) > 1 || Math.abs(dy) > 1;
                    el.x1 = initial.x1 + dx;
                    el.y1 = initial.y1 + dy;
                    el.x2 = initial.x2 + dx;
                    el.y2 = initial.y2 + dy;
                    renderElements();
                };

                const onUp = () => {
                    if (moved) saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });

            const setupEndpointDrag = (handle, pointKey) => {
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    if (!state.selectedIds.includes(el.id)) {
                        state.selectedIds = [el.id];
                        updateSelectionTools();
                    }

                    ensureLineShape(el);
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const orig = getLinePoints(el);
                    let moved = false;

                    const onMove = (moveEvent) => {
                        const dx = moveEvent.clientX - startX;
                        const dy = moveEvent.clientY - startY;
                        moved = moved || Math.abs(dx) > 0 || Math.abs(dy) > 0;
                        if (pointKey === 'start') {
                            el.x1 = orig.x1 + dx;
                            el.y1 = orig.y1 + dy;
                        } else {
                            el.x2 = orig.x2 + dx;
                            el.y2 = orig.y2 + dy;
                        }
                        renderElements();
                    };

                    const onUp = () => {
                        if (moved) saveToHistory();
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                    };

                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
            };

            setupEndpointDrag(startHandle, 'start');
            setupEndpointDrag(endHandle, 'end');
        }

        function setupImageDrag(dom, el) {
            let startX, startY, origX, origY;

            dom.addEventListener('mousedown', (e) => {
                if (state.mode === 'drawing') return;
                if (e.target.classList.contains('image-resize-handle')) return;
                e.stopPropagation();

                state.selectedIds = [el.id];
                updateSelectionTools();
                renderElements();

                startX = e.clientX;
                startY = e.clientY;
                origX = el.x;
                origY = el.y;

                const onMove = (e) => {
                    el.x = origX + (e.clientX - startX);
                    el.y = origY + (e.clientY - startY);
                    renderElements();
                };

                const onUp = () => {
                    saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        function setupImageResize(handle, el) {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                const startX = e.clientX;
                const startY = e.clientY;
                const origW = el.width;
                const origH = el.height;

                const onMove = (e) => {
                    el.width = Math.max(50, origW + (e.clientX - startX));
                    el.height = Math.max(50, origH + (e.clientY - startY));
                    renderElements();
                };

                const onUp = () => {
                    saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        function setupEmbedDrag(dom, header, el) {
            let startX, startY, origX, origY;
            let moved = false;

            const beginDrag = (e) => {
                if (state.mode === 'drawing') return;
                if (e.target.closest('.embed-resize-handle') || e.target.closest('.embed-open-btn')) return;
                e.stopPropagation();

                state.selectedIds = [el.id];
                updateSelectionTools();
                renderElements();

                startX = e.clientX;
                startY = e.clientY;
                origX = el.x;
                origY = el.y;
                moved = false;

                const onMove = (moveEvent) => {
                    const dx = moveEvent.clientX - startX;
                    const dy = moveEvent.clientY - startY;
                    if (Math.abs(dx) > 1 || Math.abs(dy) > 1) moved = true;
                    el.x = origX + dx;
                    el.y = origY + dy;
                    renderElements();
                };

                const onUp = () => {
                    if (moved) saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            };

            header.addEventListener('mousedown', beginDrag);

            dom.addEventListener('mousedown', (e) => {
                if (state.mode === 'drawing') return;
                if (e.target.closest('.embed-resize-handle') || e.target.closest('.embed-open-btn') || e.target.closest('.embed-header')) return;
                e.stopPropagation();
                state.selectedIds = [el.id];
                updateSelectionTools();
                renderElements();
            });
        }

        function setupEmbedResize(handle, el) {
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                const startX = e.clientX;
                const startY = e.clientY;
                const origW = el.width;
                const origH = el.height;

                const onMove = (moveEvent) => {
                    el.width = Math.max(320, origW + (moveEvent.clientX - startX));
                    el.height = Math.max(220, origH + (moveEvent.clientY - startY));
                    renderElements();
                };

                const onUp = () => {
                    saveToHistory();
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }

        // ============ CANVAS INTERACTIONS ============
        let selectionStart = null;
        let drawingLine = null;

        canvas.addEventListener('mousedown', (e) => {
            const target = e.target instanceof Element ? e.target : null;
            if (state.mode === 'drawing') {
                if (target && (
                    target.closest('.image-resize-handle') ||
                    target.closest('.line-handle') ||
                    target.closest('.embed-resize-handle') ||
                    target.closest('.embed-open-btn')
                )) {
                    return;
                }
            } else if (e.target !== canvas) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (state.mode === 'typing') {
                // Shift+click starts selection box even in typing mode
                if (e.shiftKey) {
                    setMode(null);
                    state.selectedIds = [];
                    updateSelectionTools();
                    selectionStart = { x, y };
                    return;
                }
                state.typingCursor.x = x;
                state.typingCursor.y = y;
                renderElements();
                return;
            }

            if (state.mode === 'drawing') {
                drawingLine = { x1: x, y1: y, x2: x, y2: y };
                return;
            }

            // Selection box
            state.selectedIds = [];
            updateSelectionTools();
            selectionStart = { x, y };
        });

        canvas.addEventListener('dblclick', (e) => {
            if (e.target !== canvas) return;
            const rect = canvas.getBoundingClientRect();
            state.typingCursor.x = e.clientX - rect.left;
            state.typingCursor.y = e.clientY - rect.top;
            setMode('typing');
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (drawingLine) {
                drawingLine.x2 = x;
                drawingLine.y2 = y;
                renderDrawingLinePreview(drawingLine.x1, drawingLine.y1, drawingLine.x2, drawingLine.y2, !!state.drawArrow);
            }

            if (selectionStart) {
                canvas.querySelectorAll('.selection-box').forEach(el => el.remove());
                const box = document.createElement('div');
                box.className = 'selection-box';
                box.style.left = Math.min(selectionStart.x, x) + 'px';
                box.style.top = Math.min(selectionStart.y, y) + 'px';
                box.style.width = Math.abs(x - selectionStart.x) + 'px';
                box.style.height = Math.abs(y - selectionStart.y) + 'px';
                canvas.appendChild(box);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (drawingLine) {
                drawingLine.x2 = x;
                drawingLine.y2 = y;
                const length = Math.hypot(drawingLine.x2 - drawingLine.x1, drawingLine.y2 - drawingLine.y1);
                if (length > 10) {
                    saveToHistory();
                    state.elements.push({
                        id: generateId(),
                        type: 'line',
                        x1: drawingLine.x1,
                        y1: drawingLine.y1,
                        x2: drawingLine.x2,
                        y2: drawingLine.y2,
                        color: '#1e293b',
                        arrowEnd: !!state.drawArrow
                    });
                }
                drawingLine = null;
                canvas.querySelectorAll('.drawing-line-preview').forEach(el => el.remove());
                setMode(null);
                renderElements();
            }

            if (selectionStart) {
                const x1 = Math.min(selectionStart.x, x);
                const x2 = Math.max(selectionStart.x, x);
                const y1 = Math.min(selectionStart.y, y);
                const y2 = Math.max(selectionStart.y, y);

                if (x2 - x1 > 5 || y2 - y1 > 5) {
                    state.selectedIds = state.elements.filter(el => {
                        if (el.type === 'line') {
                            const bounds = getLineBounds(el, 4);
                            return bounds.x < x2 && bounds.x + bounds.width > x1 &&
                                bounds.y < y2 && bounds.y + bounds.height > y1;
                        }
                        const elW = el.width || 50;
                        const elH = el.type === 'letter' ? el.fontSize * 1.2 : el.height;
                        return el.x < x2 && el.x + elW > x1 && el.y < y2 && el.y + elH > y1;
                    }).map(el => el.id);
                }

                selectionStart = null;
                updateSelectionTools();
                renderElements();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!selectionStart) return;
            if (e.target && canvas.contains(e.target)) return;

            selectionStart = null;
            canvas.querySelectorAll('.selection-box').forEach(el => el.remove());
            renderElements();
        });

        // ============ DROP LETTERS ============
        canvas.addEventListener('dragover', (e) => e.preventDefault());

        function getDefaultInsertPoint() {
            if (state.typingCursor && Number.isFinite(state.typingCursor.x) && Number.isFinite(state.typingCursor.y)) {
                return { x: state.typingCursor.x, y: state.typingCursor.y };
            }
            return {
                x: (canvasContainer.scrollLeft || 0) + (canvasContainer.clientWidth / 2),
                y: (canvasContainer.scrollTop || 0) + (canvasContainer.clientHeight / 2)
            };
        }

        function clampToCanvas(x, y, width, height) {
            const maxX = Math.max(0, canvas.offsetWidth - (width || 0));
            const maxY = Math.max(0, canvas.offsetHeight - (height || 0));
            return {
                x: Math.max(0, Math.min(maxX, x)),
                y: Math.max(0, Math.min(maxY, y))
            };
        }

        function fillImageSlot(slotId, dataUrl) {
            if (!slotId) return false;
            const slot = state.elements.find(el => el.id === slotId && el.type === 'image');
            if (!slot) return false;

            saveToHistory();
            slot.content = dataUrl;
            slot.slotType = '';
            state.selectedIds = [slot.id];
            updateSelectionTools();
            renderElements();
            return true;
        }

        function ensurePresentationCaptureSlot() {
            const existing = state.elements.find(el => el.id === pptSession.captureSlotId && el.type === 'image');
            if (existing) {
                state.selectedIds = [existing.id];
                updateSelectionTools();
                renderElements();
                return existing;
            }

            const point = getDefaultInsertPoint();
            const slotWidth = 420;
            const slotHeight = 250;
            const bounded = clampToCanvas(point.x, point.y, slotWidth, slotHeight);
            const slot = {
                id: generateId(),
                type: 'image',
                content: '',
                slotType: 'ppt-capture',
                x: bounded.x,
                y: bounded.y,
                width: slotWidth,
                height: slotHeight
            };

            saveToHistory();
            state.elements.push(slot);
            state.selectedIds = [slot.id];
            updateSelectionTools();
            renderElements();
            pptSession.captureSlotId = slot.id;
            return slot;
        }

        function insertImageDataUrl(dataUrl, x, y, options) {
            const opts = options || {};

            if (opts.slotId && fillImageSlot(opts.slotId, dataUrl)) {
                return;
            }

            const img = new Image();
            img.onload = () => {
                const maxW = 300;
                const scale = img.width > maxW ? maxW / img.width : 1;
                const width = img.width * scale;
                const height = img.height * scale;
                const point = clampToCanvas(Math.max(0, x - width / 2), Math.max(0, y - height / 2), width, height);

                saveToHistory();
                const inserted = {
                    id: generateId(),
                    type: 'image',
                    content: dataUrl,
                    x: point.x,
                    y: point.y,
                    width,
                    height
                };
                state.elements.push(inserted);
                state.selectedIds = [inserted.id];
                updateSelectionTools();
                renderElements();
            };
            img.src = dataUrl;
        }

        function insertImageFile(file, x, y, options) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                insertImageDataUrl(ev.target.result, x, y, options);
            };
            reader.readAsDataURL(file);
        }

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const droppedFiles = e.dataTransfer?.files;
            if (droppedFiles && droppedFiles.length > 0) {
                const imageFile = Array.from(droppedFiles).find(file => file.type && file.type.startsWith('image/'));
                if (imageFile) {
                    const slotId = pptSession.captureArmed ? pptSession.captureSlotId : '';
                    insertImageFile(imageFile, x, y, { slotId });
                    if (pptSession.captureArmed) {
                        pptSession.captureArmed = false;
                        pptSession.captureSlotId = '';
                        showToast('Slide image inserted');
                    }
                    return;
                }
            }

            const data = e.dataTransfer.getData('text/plain');
            if (data) {
                try {
                    const { letter } = JSON.parse(data);
                    const props = findNearestLetterProps(x, y);
                    const fontSize = props.fontSize;
                    const width = getLetterWidth(letter, fontSize);
                    const effectiveSpacing = getEffectiveSpacing(props.spacing, fontSize);

                    let finalX = x - width / 2;
                    let finalY = y - fontSize / 2;

                    // Snap to nearest letter
                    if (props.nearest && state.autoSnap) {
                        const snapX = props.nearest.x + props.nearest.width + effectiveSpacing;
                        if (Math.abs(finalX - snapX) < 100) {
                            finalX = snapX;
                            finalY = props.nearest.y;
                        }
                    }

                    // Snap to line
                    if (state.autoSnap) {
                        const lines = state.elements.filter(el => el.type === 'line');
                        const descenders = new Set(['ј', 'р', 'у', 'ф', 'ц', 'ш', 'ѕ', 'ѓ', 'ќ']);
                        const hasDescender = descenders.has(letter.toLowerCase());
                        const baselineRatio = hasDescender ? 0.8 : 1.0;
                        const height = fontSize * 1.2;
                        const baselinePos = height * baselineRatio;

                        for (const line of lines) {
                            const baseline = getHorizontalLineBaseline(line);
                            if (!baseline) continue;

                            if (finalX + width > baseline.x1 && finalX < baseline.x2) {
                                const elBaseline = finalY + baselinePos;
                                if (Math.abs(elBaseline - baseline.y) < SNAP_THRESHOLD * 3) {
                                    finalY = baseline.y - baselinePos;
                                    break;
                                }
                            }
                        }
                    }

                    saveToHistory();
                    state.elements.push({
                        id: generateId(),
                        type: 'letter',
                        content: letter,
                        x: finalX,
                        y: finalY,
                        fontSize,
                        width,
                        color: props.color || '#1e293b'
                    });
                    renderElements();
                } catch (err) {}
            }
        });

        // ============ KEYBOARD ============
        function renderKeyboard() {
            const fontSize = Math.max(14, Math.min(32, keyboard.offsetWidth / 20));
            const keySize = fontSize * 1.3;
            const gap = fontSize * 0.15;

            const rows = state.keyboardLayout === 'mk'
                ? [
                    ['љ', 'њ', 'е', 'р', 'т', 'ѕ', 'у', 'и', 'о', 'п', 'ш', 'ѓ'],
                    ['а', 'с', 'д', 'ф', 'г', 'х', 'ј', 'к', 'л', 'ч', 'ќ'],
                    ['з', 'џ', 'ц', 'в', 'б', 'н', 'м']
                ]
                : [
                    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
                    ['z', 'x', 'c', 'v', 'b', 'n', 'm']
                ];

            keyboardBody.innerHTML = '';
            keyboardBody.style.padding = (fontSize * 0.4) + 'px';
            updateKeyboardLayoutUI();

            for (const row of rows) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                rowDiv.style.gap = gap + 'px';
                rowDiv.style.marginBottom = gap + 'px';

                for (const char of row) {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.style.width = keySize + 'px';
                    key.style.height = keySize + 'px';
                    key.style.fontSize = (fontSize * 0.7) + 'px';
                    key.textContent = state.keyboardCaps ? char.toUpperCase() : char;
                    key.draggable = true;

                    key.addEventListener('dragstart', (e) => {
                        const letter = state.keyboardCaps ? char.toUpperCase() : char;
                        e.dataTransfer.setData('text/plain', JSON.stringify({ letter }));
                    });

                    rowDiv.appendChild(key);
                }
                keyboardBody.appendChild(rowDiv);
            }

            // Bottom row with Caps and Space
            const bottomRow = document.createElement('div');
            bottomRow.className = 'keyboard-row';
            bottomRow.style.gap = gap + 'px';

            const capsKey = document.createElement('div');
            capsKey.className = 'key key-special key-caps' + (state.keyboardCaps ? ' active' : '');
            capsKey.style.width = (keySize * 2) + 'px';
            capsKey.style.height = keySize + 'px';
            capsKey.style.fontSize = (fontSize * 0.55) + 'px';
            capsKey.textContent = t('caps');
            capsKey.addEventListener('click', () => {
                state.keyboardCaps = !state.keyboardCaps;
                renderKeyboard();
            });
            bottomRow.appendChild(capsKey);

            const spaceKey = document.createElement('div');
            spaceKey.className = 'key';
            spaceKey.style.width = (keySize * 6) + 'px';
            spaceKey.style.height = keySize + 'px';
            spaceKey.draggable = true;
            spaceKey.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ letter: ' ' }));
            });
            bottomRow.appendChild(spaceKey);

            keyboardBody.appendChild(bottomRow);
        }

        // Keyboard positioning and resizing
        function ensureKeyboardVisible(forceBottom) {
            const mainArea = document.querySelector('.main-area');
            if (!mainArea) return;

            const margin = 12;
            const areaW = mainArea.clientWidth;
            const areaH = mainArea.clientHeight;
            const kbW = keyboard.offsetWidth || 420;
            const kbH = keyboard.offsetHeight || 240;

            let x = parseFloat(keyboard.style.left);
            let y = parseFloat(keyboard.style.top);

            const maxX = Math.max(margin, areaW - kbW - margin);
            const maxY = Math.max(margin, areaH - kbH - margin);

            if (!Number.isFinite(x)) x = Math.max(margin, Math.min(maxX, (areaW - kbW) / 2));
            if (!Number.isFinite(y) || forceBottom) y = maxY;

            x = Math.max(margin, Math.min(maxX, x));
            y = Math.max(margin, Math.min(maxY, y));

            keyboard.style.left = x + 'px';
            keyboard.style.top = y + 'px';
        }

        function initKeyboard() {
            keyboard.style.width = '460px';
            keyboard.classList.toggle('hidden', !state.keyboardVisible);
            renderKeyboard();
            updateKeyboardLockUI();
            requestAnimationFrame(() => ensureKeyboardVisible(true));
        }

        // Keyboard drag
        let kbDragging = false, kbOffsetX, kbOffsetY;

        keyboardHeader.addEventListener('mousedown', (e) => {
            if (state.keyboardLocked) return;
            kbDragging = true;
            kbOffsetX = e.clientX - keyboard.offsetLeft;
            kbOffsetY = e.clientY - keyboard.offsetTop;
            keyboardHeader.classList.add('draggable');
        });

        document.addEventListener('mousemove', (e) => {
            if (kbDragging) {
                keyboard.style.left = (e.clientX - kbOffsetX) + 'px';
                keyboard.style.top = (e.clientY - kbOffsetY) + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            if (kbDragging) {
                kbDragging = false;
                ensureKeyboardVisible(false);
                return;
            }
            kbDragging = false;
        });

        // Keyboard resize
        const kbResize = document.getElementById('keyboardResize');
        let kbResizing = false, kbStartW, kbStartX;

        kbResize.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            kbResizing = true;
            kbStartW = keyboard.offsetWidth;
            kbStartX = e.clientX;
        });

        document.addEventListener('mousemove', (e) => {
            if (kbResizing) {
                const newW = Math.max(280, Math.min(700, kbStartW + (e.clientX - kbStartX)));
                keyboard.style.width = newW + 'px';
                renderKeyboard();
            }
        });

        document.addEventListener('mouseup', () => {
            if (kbResizing) {
                kbResizing = false;
                ensureKeyboardVisible(false);
                return;
            }
            kbResizing = false;
        });

        // Lock button
        lockBtn.addEventListener('click', () => {
            state.keyboardLocked = !state.keyboardLocked;
            updateKeyboardLockUI();
            showToast(state.keyboardLocked ? '🔒 Keyboard locked' : '🔓 Keyboard unlocked');
        });

        keyboardLayoutBtn.addEventListener('click', () => {
            state.keyboardLayout = state.keyboardLayout === 'mk' ? 'en' : 'mk';
            state.keyboardCaps = false;
            updateKeyboardLayoutUI();
            renderKeyboard();
            showToast(state.keyboardLayout === 'mk' ? 'MK keyboard' : 'EN keyboard');
        });

        // ============ TOOLBAR BUTTONS ============
        // All tools visible - no tab switching needed

        function setMode(mode) {
            state.mode = mode;
            canvas.classList.remove('mode-drawing', 'mode-painting', 'mode-typing');
            document.getElementById('paintBtn').classList.remove('active-rose');
            document.getElementById('typeBtn').classList.remove('active-green');
            document.getElementById('lineBtn').classList.remove('active');

            const indicator = document.getElementById('modeIndicator');
            if (mode === 'drawing') {
                canvas.classList.add('mode-drawing');
                document.getElementById('lineBtn').classList.add('active');
                if (indicator) { indicator.textContent = '✏️ Линија (Esc за излез)'; indicator.style.display = ''; }
            } else if (mode === 'painting') {
                canvas.classList.add('mode-painting');
                document.getElementById('paintBtn').classList.add('active-rose');
                if (indicator) { indicator.textContent = '🖌️ Боење (Esc за излез)'; indicator.style.display = ''; }
            } else if (mode === 'typing') {
                canvas.classList.add('mode-typing');
                document.getElementById('typeBtn').classList.add('active-green');
                if (indicator) { indicator.textContent = '⌨️ Пишување (Esc за излез | Shift+клик за селекција)'; indicator.style.display = ''; }
            } else {
                if (indicator) { indicator.style.display = 'none'; }
            }
            renderElements();
        }

        document.getElementById('paintBtn').addEventListener('click', () => {
            setMode(state.mode === 'painting' ? null : 'painting');
        });

        document.getElementById('typeBtn').addEventListener('click', () => {
            setMode(state.mode === 'typing' ? null : 'typing');
        });

        document.getElementById('lineBtn').addEventListener('click', () => {
            setMode(state.mode === 'drawing' ? null : 'drawing');
        });

        document.getElementById('arrowToggleBtn').addEventListener('click', () => {
            state.drawArrow = !state.drawArrow;
            document.getElementById('arrowToggleBtn').classList.toggle('active', state.drawArrow);
            if (state.mode !== 'drawing') setMode('drawing');
        });

        document.getElementById('typingColorPicker').addEventListener('input', (e) => {
            state.typingColor = e.target.value;
        });

        function normalizePresentationSource(rawUrl) {
            try {
                const url = new URL((rawUrl || '').trim());
                if (!/^https?:$/i.test(url.protocol)) return null;

                if (url.hostname.includes('dropbox.com')) {
                    if (url.hostname === 'www.dropbox.com') {
                        url.hostname = 'dl.dropboxusercontent.com';
                    }
                    url.searchParams.delete('dl');
                    url.searchParams.set('raw', '1');
                }

                return url.toString();
            } catch (err) {
                return null;
            }
        }

        function buildPresentationEmbedUrl(sourceUrl) {
            const normalized = (sourceUrl || '').trim();
            const lower = normalized.toLowerCase();

            if (/docs\.google\.com\/presentation/i.test(lower)) {
                return normalized.replace('/edit', '/preview');
            }

            if (/docs\.google\.com\/document/i.test(lower)) {
                return normalized.replace('/edit', '/preview');
            }

            if (/docs\.google\.com\/spreadsheets/i.test(lower)) {
                return normalized.replace('/edit', '/preview');
            }

            if (/\.pdf($|[?#])/i.test(lower)) {
                return normalized;
            }

            // Images - open directly
            if (/\.(png|jpg|jpeg|gif|svg|webp|bmp)($|[?#])/i.test(lower)) {
                return normalized;
            }

            // Office documents - use Office Online viewer
            if (/\.(pptx?|docx?|xlsx?)($|[?#])/i.test(lower)) {
                return 'https://view.officeapps.live.com/op/embed.aspx?src=' + encodeURIComponent(normalized);
            }

            // Any other URL (websites, etc) - open directly in iframe
            return normalized;
        }

        function ensurePptViewerVisible() {
            if (!pptViewer) return;
            const mainArea = document.querySelector('.main-area');
            if (!mainArea) return;

            const margin = 8;
            const maxX = Math.max(margin, mainArea.clientWidth - pptViewer.offsetWidth - margin);
            const maxY = Math.max(margin, mainArea.clientHeight - pptViewer.offsetHeight - margin);

            let x = parseFloat(pptViewer.style.left);
            let y = parseFloat(pptViewer.style.top);
            if (!Number.isFinite(x)) x = maxX;
            if (!Number.isFinite(y)) y = margin;

            x = Math.max(margin, Math.min(maxX, x));
            y = Math.max(margin, Math.min(maxY, y));

            pptViewer.style.left = x + 'px';
            pptViewer.style.top = y + 'px';
            pptViewer.style.right = 'auto';
        }

        function showPptViewer() {
            pptViewer.classList.remove('hidden');
            document.getElementById('pptToggleBtn').classList.add('active');
            requestAnimationFrame(ensurePptViewerVisible);
        }

        function hidePptViewer() {
            pptViewer.classList.add('hidden');
            pptViewer.classList.remove('minimized');
            document.getElementById('pptToggleBtn').classList.remove('active');
            document.getElementById('pptViewerMinBtn').style.display = '';
            document.getElementById('pptViewerMaxBtn').style.display = 'none';
        }

        function minimizePptViewer() {
            // Save current size/position before minimizing
            if (!pptViewer.classList.contains('minimized')) {
                pptViewer._savedWidth = pptViewer.style.width;
                pptViewer._savedHeight = pptViewer.style.height;
                pptViewer._savedTop = pptViewer.style.top;
                pptViewer._savedLeft = pptViewer.style.left;
            }
            pptViewer.classList.add('minimized');
            document.getElementById('pptViewerMinBtn').style.display = 'none';
            document.getElementById('pptViewerMaxBtn').style.display = '';
            document.getElementById('pptToggleBtn').classList.add('active');
        }

        function restorePptViewer() {
            pptViewer.classList.remove('minimized');
            // Restore saved size/position
            if (pptViewer._savedWidth) pptViewer.style.width = pptViewer._savedWidth;
            if (pptViewer._savedHeight) pptViewer.style.height = pptViewer._savedHeight;
            if (pptViewer._savedTop) pptViewer.style.top = pptViewer._savedTop;
            if (pptViewer._savedLeft) pptViewer.style.left = pptViewer._savedLeft;
            document.getElementById('pptViewerMinBtn').style.display = '';
            document.getElementById('pptViewerMaxBtn').style.display = 'none';
            requestAnimationFrame(ensurePptViewerVisible);
        }

        function closePptViewer() {
            hidePptViewer();
            pptSession.sourceUrl = '';
            pptSession.embedUrl = '';
            pptSession.captureArmed = false;
            pptSession.captureSlotId = '';
            if (pptLinkInput) pptLinkInput.value = '';
            if (pptViewerFrame) pptViewerFrame.src = 'about:blank';
        }

        function loadPresentationIntoViewer(rawUrl) {
            const sourceUrl = normalizePresentationSource(rawUrl);
            if (!sourceUrl) {
                showToast('Invalid document link');
                return;
            }

            const embedUrl = buildPresentationEmbedUrl(sourceUrl);
            pptSession.sourceUrl = sourceUrl;
            pptSession.embedUrl = embedUrl;
            pptSession.captureArmed = false;
            pptSession.captureSlotId = '';

            if (pptLinkInput) pptLinkInput.value = sourceUrl;
            if (pptViewerFrame) pptViewerFrame.src = embedUrl;
            showPptViewer();
            showToast('Document loaded');
        }

        function armPresentationCapture() {
            if (!pptSession.sourceUrl) {
                showToast('Прво вчитај документ');
                return;
            }
            ensurePresentationCaptureSlot();
            pptSession.captureArmed = true;
            minimizePptViewer();
            showToast('📸 Сними го екранот (Win+Shift+S), па Ctrl+V овде');
        }

        document.getElementById('pptBtn').addEventListener('click', () => {
            const suggested = (pptLinkInput && pptLinkInput.value.trim()) || pptSession.sourceUrl || '';
            const link = window.prompt('Линк до документ, слика или веб страна\n(PPT/DOC/PDF/Google Docs/слика/URL)', suggested);
            if (!link) {
                if (pptSession.sourceUrl) showPptViewer();
                return;
            }
            loadPresentationIntoViewer(link);
        });

        document.getElementById('pptToggleBtn').addEventListener('click', () => {
            if (pptViewer.classList.contains('minimized')) {
                restorePptViewer();
                return;
            }
            if (pptViewer.classList.contains('hidden')) {
                if (!pptSession.sourceUrl) {
                    showToast('Use Files button to load link first');
                    return;
                }
                showPptViewer();
            } else {
                minimizePptViewer();
            }
        });

        document.getElementById('pptLoadBtn').addEventListener('click', () => {
            loadPresentationIntoViewer(pptLinkInput.value);
        });

        document.getElementById('pptCaptureBtn').addEventListener('click', armPresentationCapture);
        document.getElementById('pptViewerCloseBtn').addEventListener('click', closePptViewer);

        document.getElementById('pasteImageBtn').addEventListener('click', () => {
            showToast('📋 Направи screenshot (Win+Shift+S), па Ctrl+V');
        });
        document.getElementById('pptViewerMinBtn').addEventListener('click', minimizePptViewer);
        document.getElementById('pptViewerMaxBtn').addEventListener('click', restorePptViewer);

        // Click on minimized viewer header to restore
        pptViewer.addEventListener('click', (e) => {
            if (pptViewer.classList.contains('minimized') && !e.target.closest('button')) {
                restorePptViewer();
            }
        });

        let pptDragging = false;
        let pptDragOffsetX = 0;
        let pptDragOffsetY = 0;
        let pptResizing = false;
        let pptStartW = 0;
        let pptStartH = 0;
        let pptStartX = 0;
        let pptStartY = 0;

        pptViewerHeader.addEventListener('mousedown', (e) => {
            if (e.target.closest('button')) return;
            pptDragging = true;
            pptDragOffsetX = e.clientX - pptViewer.offsetLeft;
            pptDragOffsetY = e.clientY - pptViewer.offsetTop;
            e.preventDefault();
        });

        pptViewerResize.addEventListener('mousedown', (e) => {
            pptResizing = true;
            pptStartW = pptViewer.offsetWidth;
            pptStartH = pptViewer.offsetHeight;
            pptStartX = e.clientX;
            pptStartY = e.clientY;
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (pptDragging) {
                pptViewer.style.left = (e.clientX - pptDragOffsetX) + 'px';
                pptViewer.style.top = (e.clientY - pptDragOffsetY) + 'px';
                ensurePptViewerVisible();
            }

            if (pptResizing) {
                const newW = Math.max(460, Math.min(1200, pptStartW + (e.clientX - pptStartX)));
                const newH = Math.max(280, Math.min(900, pptStartH + (e.clientY - pptStartY)));
                pptViewer.style.width = newW + 'px';
                pptViewer.style.height = newH + 'px';
                ensurePptViewerVisible();
            }
        });

        document.addEventListener('mouseup', () => {
            pptDragging = false;
            pptResizing = false;
        });

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);

        document.getElementById('snapBtn').addEventListener('click', () => {
            state.autoSnap = !state.autoSnap;
            document.getElementById('snapStatus').textContent = state.autoSnap ? t('on') : t('off');
            document.getElementById('snapBtn').classList.toggle('active-green', state.autoSnap);
        });

        document.getElementById('spacingSlider').addEventListener('input', (e) => {
            state.letterSpacing = getEffectiveSpacing(parseInt(e.target.value, 10), getContextFontSize());
            e.target.value = state.letterSpacing;

            if (state.selectedIds.some(id => {
                const el = state.elements.find(item => item.id === id);
                return el && el.type === 'letter';
            })) {
                reflowSelectedLetters();
                renderElements();
            }
        });

        document.getElementById('spacingSlider').addEventListener('change', saveToHistory);

        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (state.selectedIds.length > 0) {
                saveToHistory();
                if (pptSession.captureSlotId && state.selectedIds.includes(pptSession.captureSlotId)) {
                    pptSession.captureSlotId = '';
                    pptSession.captureArmed = false;
                }
                state.elements = state.elements.filter(el => !state.selectedIds.includes(el.id));
                state.selectedIds = [];
                updateSelectionTools();
                renderElements();
            }
        });

        document.getElementById('makeCardBtn').addEventListener('click', () => {
            const selectedVisual = state.elements.filter(el =>
                state.selectedIds.includes(el.id) && (el.type === 'image' || el.type === 'card')
            );
            if (selectedVisual.length !== 1) return;

            const target = selectedVisual[0];

            if (target.type === 'image') {
                if (!target.content) {
                    showToast('Fill image slot first');
                    return;
                }

                const asked = window.prompt('Card label', target.label || 'Етикета');
                if (asked === null) return;

                saveToHistory();
                target.type = 'card';
                target.label = asked.trim() || 'Етикета';
                target.borderColor = target.borderColor || '#a8d4ff';
                target.textColor = target.textColor || '#1a1a2e';
                target.width = Math.max(180, target.width || 180);
                target.height = Math.max(220, target.height || 220);
                state.selectedIds = [target.id];
                updateSelectionTools();
                renderElements();
                showToast('Image converted to card');
                return;
            }

            const updated = window.prompt('Card label', target.label || 'Етикета');
            if (updated === null) return;
            saveToHistory();
            target.label = updated.trim() || 'Етикета';
            state.selectedIds = [target.id];
            updateSelectionTools();
            renderElements();
            showToast('Card label updated');
        });

        document.getElementById('alignBtn').addEventListener('click', () => {
            const letters = state.elements.filter(el =>
                state.selectedIds.includes(el.id) && el.type === 'letter'
            ).sort((a, b) => a.x - b.x);

            if (letters.length < 2) return;

            saveToHistory();
            const anchor = letters[0];

            for (let i = 0; i < letters.length; i++) {
                letters[i].y = anchor.y;
                letters[i].fontSize = anchor.fontSize;
                letters[i].width = getLetterWidth(letters[i].content, anchor.fontSize);
            }

            reflowLetterSequence(letters, state.letterSpacing);
            renderElements();
        });

        const DEFAULT_ROW_FONT_SIZE = 48;
        const DEFAULT_ROW_SPACING = getEffectiveSpacing(DEFAULT_LETTER_SPACING, DEFAULT_ROW_FONT_SIZE);

        document.getElementById('alignDefaultBtn').addEventListener('click', () => {
            const letters = state.elements.filter(el =>
                state.selectedIds.includes(el.id) && el.type === 'letter'
            );

            if (letters.length < 2) return;

            saveToHistory();

            const sortedByRowAnchor = [...letters].sort((a, b) => (a.y - b.y) || (a.x - b.x));
            const anchorY = sortedByRowAnchor[0].y;
            const sortedByX = [...letters].sort((a, b) => a.x - b.x);

            for (const letter of sortedByX) {
                letter.y = anchorY;
                letter.fontSize = DEFAULT_ROW_FONT_SIZE;
                letter.width = getLetterWidth(letter.content, DEFAULT_ROW_FONT_SIZE);
            }

            state.letterSpacing = DEFAULT_ROW_SPACING;
            document.getElementById('spacingSlider').value = state.letterSpacing;
            document.getElementById('sizeSlider').value = 100;

            reflowLetterSequence(sortedByX, state.letterSpacing);
            renderElements();
        });
        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            const scale = parseInt(e.target.value) / 100;
            const newSize = 48 * scale;

            state.letterSpacing = getEffectiveSpacing(state.letterSpacing, newSize);
            document.getElementById('spacingSlider').value = state.letterSpacing;

            for (const id of state.selectedIds) {
                const el = state.elements.find(el => el.id === id);
                if (el && el.type === 'letter') {
                    el.fontSize = newSize;
                    el.width = getLetterWidth(el.content, newSize);
                }
            }

            reflowSelectedLetters();
            renderElements();
        });

        document.getElementById('sizeSlider').addEventListener('change', saveToHistory);

        document.getElementById('saveBtn').addEventListener('click', () => {
            localStorage.setItem('whiteboard-template', JSON.stringify(state.elements));
            showToast(t('saved'));
        });

        // ============ EXPORT BOARD AS PNG ============
        document.getElementById('exportPngBtn').addEventListener('click', () => {
            if (typeof html2canvas === 'undefined') {
                showToast('html2canvas не е вчитан');
                return;
            }
            showToast('Се генерира слика...');
            // Hide selection highlights, cursor, keyboard before capture
            const oldMode = state.mode;
            const oldSelectedIds = [...state.selectedIds];
            state.selectedIds = [];
            state.mode = null;
            canvas.classList.remove('mode-drawing', 'mode-painting', 'mode-typing');
            renderElements();

            // Hide keyboard and toolbar temporarily
            const kbWasVisible = !keyboard.classList.contains('hidden');
            if (kbWasVisible) keyboard.style.display = 'none';
            const toolbar = document.querySelector('.toolbar');
            if (toolbar) toolbar.style.display = 'none';

            setTimeout(() => {
                html2canvas(canvas, {
                    useCORS: true,
                    scale: 2,
                    backgroundColor: getComputedStyle(canvas).backgroundColor || '#e2e8f0',
                    width: canvas.scrollWidth,
                    height: canvas.scrollHeight
                }).then(exportCanvas => {
                    const link = document.createElement('a');
                    link.download = 'WBACC-Tabla-' + new Date().toISOString().slice(0,10) + '.png';
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                    showToast('Сликата е зачувана!');
                }).catch(err => {
                    console.error('Export error:', err);
                    showToast('Грешка при експорт');
                }).finally(() => {
                    // Restore state
                    if (kbWasVisible) keyboard.style.display = '';
                    if (toolbar) toolbar.style.display = '';
                    state.selectedIds = oldSelectedIds;
                    state.mode = oldMode;
                    renderElements();
                });
            }, 200);
        });

        document.getElementById('keyboardToggle').addEventListener('click', () => {
            state.keyboardVisible = !state.keyboardVisible;
            keyboard.classList.toggle('hidden', !state.keyboardVisible);
            document.getElementById('keyboardToggleText').textContent = 
                state.keyboardVisible ? t('hide') : t('show');

            if (state.keyboardVisible) {
                renderKeyboard();
                requestAnimationFrame(() => ensureKeyboardVisible(false));
            }
        });

        document.getElementById('langToggle').addEventListener('click', () => {
            currentLang = currentLang === 'mk' ? 'en' : 'mk';
            updateLanguage();
            renderKeyboard();
        });

        window.addEventListener('resize', () => {
            if (state.keyboardVisible) {
                renderKeyboard();
                requestAnimationFrame(() => ensureKeyboardVisible(false));
            }
            if (!pptViewer.classList.contains('hidden')) {
                requestAnimationFrame(ensurePptViewerVisible);
            }
        });

        // Color palette
        const colors = ['#1e293b', '#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#ec4899'];
        const palette = document.getElementById('colorPalette');
        colors.forEach(color => {
            const btn = document.createElement('div');
            btn.className = 'color-btn';
            btn.style.backgroundColor = color;
            btn.addEventListener('click', () => {
                saveToHistory();
                for (const id of state.selectedIds) {
                    const el = state.elements.find(e => e.id === id);
                    if (el) el.color = color;
                }
                renderElements();
            });
            palette.appendChild(btn);
        });

        // ============ KEYBOARD SHORTCUTS ============
        document.addEventListener('keydown', (e) => {
            const target = e.target instanceof HTMLElement ? e.target : null;
            const isEditableTarget = !!target && (
                target.isContentEditable ||
                target.tagName === 'INPUT' ||
                target.tagName === 'TEXTAREA' ||
                target.closest('.wb-textbox')
            );
            if (isEditableTarget) return;

            // Escape exits any mode
            if (e.key === 'Escape' && state.mode) {
                e.preventDefault();
                setMode(null);
                return;
            }

            if (state.mode === 'typing') {
                handleTyping(e);
                return;
            }

            const isPrintable = e.key && e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey;
            if (isPrintable) {
                setMode('typing');
                handleTyping(e);
                return;
            }

            if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedIds.length > 0) {
                document.getElementById('deleteBtn').click();
            }

            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }

            if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // QWERTY to Cyrillic mapping
        const qwertyCyrillic = {
            'q': 'љ', 'w': 'њ', 'e': 'е', 'r': 'р', 't': 'т', 'y': 'ѕ', 'u': 'у', 'i': 'и', 'o': 'о', 'p': 'п',
            'a': 'а', 's': 'с', 'd': 'д', 'f': 'ф', 'g': 'г', 'h': 'х', 'j': 'ј', 'k': 'к', 'l': 'л',
            'z': 'з', 'x': 'џ', 'c': 'ц', 'v': 'в', 'b': 'б', 'n': 'н', 'm': 'м',
            '[': 'ш', ']': 'ѓ', ';': 'ч', "'": 'ќ'
        };

        function handleTyping(e) {
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            if (e.key === 'Escape') {
                setMode(null);
                return;
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                state.typingCursor.x = 100;
                state.typingCursor.y += state.typingCursor.fontSize * 1.5;
                renderElements();
                return;
            }

            // ====== BACKSPACE / DELETE in typing mode ======
            if (e.key === 'Backspace' || e.key === 'Delete') {
                e.preventDefault();
                // Find the nearest letter to the left of the cursor on the same line
                const curX = state.typingCursor.x;
                const curY = state.typingCursor.y;
                const curFontSize = state.typingCursor.fontSize || 48;
                const lineThreshold = curFontSize * 0.5;

                // Get all letters on the same line, sorted by x position
                const sameLineLetters = state.elements
                    .filter(el => el.type === 'letter' && Math.abs(el.y - curY) < lineThreshold)
                    .sort((a, b) => a.x - b.x);

                // Find the letter closest to the left of the cursor
                let target = null;
                for (let i = sameLineLetters.length - 1; i >= 0; i--) {
                    const el = sameLineLetters[i];
                    if (el.x < curX + 5) { // small tolerance
                        target = el;
                        break;
                    }
                }

                if (target) {
                    saveToHistory();
                    // Move cursor back to the deleted letter's position
                    state.typingCursor.x = target.x;
                    state.typingCursor.fontSize = target.fontSize || curFontSize;
                    // Remove the letter
                    state.elements = state.elements.filter(el => el.id !== target.id);
                    renderElements();
                }
                return;
            }

            let char = e.key;
            if (state.keyboardLayout === 'mk' && qwertyCyrillic[char.toLowerCase()]) {
                char = e.shiftKey ? qwertyCyrillic[char.toLowerCase()].toUpperCase() : qwertyCyrillic[char.toLowerCase()];
            } else if (state.keyboardLayout === 'en' && /^[a-z]$/i.test(char)) {
                char = e.shiftKey ? char.toUpperCase() : char.toLowerCase();
            }

            const isCyrillic = /[\u0400-\u04FF]/.test(char);
            const isLatin = /[A-Za-z]/.test(char);
            const isPunct = /[0-9,.\?!;:\-\(\) '"`]/.test(char);
             
            if (!isCyrillic && !isLatin && !isPunct) return;
            
            e.preventDefault();

            const props = findNearestLetterProps(state.typingCursor.x, state.typingCursor.y);
            const fontSize = props.fontSize || state.typingCursor.fontSize;
            const width = getLetterWidth(char, fontSize);
            const effectiveSpacing = getEffectiveSpacing(props.spacing, fontSize);

            saveToHistory();
            state.elements.push({
                id: generateId(),
                type: 'letter',
                content: char,
                x: state.typingCursor.x,
                y: state.typingCursor.y,
                fontSize,
                width,
                color: state.typingColor || '#1e293b'
            });

            state.typingCursor.x += width + effectiveSpacing;
            state.letterSpacing = effectiveSpacing;
            document.getElementById('spacingSlider').value = state.letterSpacing;
            state.typingCursor.fontSize = fontSize;
            renderElements();
        }

        // ============ IMAGE PASTE ============
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    const point = getDefaultInsertPoint();
                    const slotId = pptSession.captureArmed ? pptSession.captureSlotId : '';
                    insertImageFile(file, point.x, point.y, { slotId });
                    if (pptSession.captureArmed) {
                        pptSession.captureArmed = false;
                        pptSession.captureSlotId = '';
                        showToast('Slide image inserted');
                    }
                    e.preventDefault();
                    break;
                }
            }
        });

        // ============ INIT ============
        function init() {
            const saved = localStorage.getItem('whiteboard-template');
            if (saved) {
                try {
                    state.elements = JSON.parse(saved);
                } catch (e) {}
            }

            updateLanguage();
            initKeyboard();
            document.getElementById('spacingSlider').value = state.letterSpacing;
            applyToolbarTab('home');
            renderElements();
            updateSelectionTools();
        }

        init();
    </script>
    <script src="home-button.js"></script>
    <script>
        (function() {
            if (typeof renderElements === 'function') {
                const originalRenderElements = renderElements;
                renderElements = function() {
                    if (typeof state !== 'undefined' && Array.isArray(state.elements) && typeof getLetterWidth === 'function') {
                        for (const el of state.elements) {
                            if (el && el.type === 'letter') {
                                el.width = getLetterWidth(el.content, el.fontSize || 48);
                            }
                        }
                    }
                    return originalRenderElements();
                };
                renderElements();
            }

            const DEFAULT_TEXTBOX_BG = '#ffffff';
            const DEFAULT_TEXTBOX_OPACITY = 98;
            const DEFAULT_TEXTBOX_OUTLINE = true;

            let textBoxMode = false;
            let activeTextBox = null;
            let textBoxCounter = 0;

            const wbCanvas = document.getElementById('canvas');
            const wbCanvasContainer = document.getElementById('canvasContainer');
            const typeBtn = document.getElementById('typeBtn');
            const textControlsGroup = document.getElementById('textBoxToolsGroup');
            const toolbarGroup = textControlsGroup || (typeBtn ? typeBtn.parentElement : null);
            const textBoxBgColorInput = document.getElementById('textBoxBgColor');
            const textBoxFontColorInput = document.getElementById('textBoxFontColor');
            const textBoxBorderColorInput = document.getElementById('textBoxBorderColor');
            const textBoxOpacityInput = document.getElementById('textBoxOpacity');
            const textBoxOutlineInput = document.getElementById('textBoxOutline');
            const textBoxFontSizeInput = document.getElementById('textBoxFontSize');

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function hexToRgba(hex, opacityPercent) {
                const normalized = (hex || DEFAULT_TEXTBOX_BG).replace('#', '').trim();
                const safeHex = normalized.length === 3
                    ? normalized.split('').map(ch => ch + ch).join('')
                    : normalized.padEnd(6, 'f').slice(0, 6);

                const r = parseInt(safeHex.slice(0, 2), 16);
                const g = parseInt(safeHex.slice(2, 4), 16);
                const b = parseInt(safeHex.slice(4, 6), 16);
                const alpha = clamp((opacityPercent || DEFAULT_TEXTBOX_OPACITY) / 100, 0.1, 1);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function clearLetterSelection() {
                if (typeof state === 'undefined' || !Array.isArray(state.selectedIds)) return;
                if (state.selectedIds.length === 0) return;
                state.selectedIds = [];
                if (typeof updateSelectionTools === 'function') updateSelectionTools();
                if (typeof renderElements === 'function') renderElements();
            }

            function applyTextBoxStyle(box, bgColor, opacityPercent) {
                if (!box) return;
                const safeColor = bgColor || DEFAULT_TEXTBOX_BG;
                const safeOpacity = clamp(parseInt(opacityPercent, 10) || DEFAULT_TEXTBOX_OPACITY, 10, 100);

                box.dataset.bgColor = safeColor;
                box.dataset.bgOpacity = String(safeOpacity);
                box.style.background = hexToRgba(safeColor, safeOpacity);
            }

            function applyTextBoxOutline(box, outlineVisible) {
                if (!box) return;
                const showOutline = !(outlineVisible === false || outlineVisible === '0');
                box.dataset.outlineVisible = showOutline ? '1' : '0';
                box.classList.toggle('no-outline', !showOutline);
            }

            function setActiveTextBox(box, syncControls) {
                if (activeTextBox && activeTextBox !== box) {
                    activeTextBox.classList.remove('active');
                }

                activeTextBox = box || null;

                if (activeTextBox) {
                    activeTextBox.classList.add('active');
                    if (syncControls) {
                        if (textBoxBgColorInput) {
                            textBoxBgColorInput.value = activeTextBox.dataset.bgColor || DEFAULT_TEXTBOX_BG;
                        }
                        if (textBoxOpacityInput) {
                            textBoxOpacityInput.value = activeTextBox.dataset.bgOpacity || String(DEFAULT_TEXTBOX_OPACITY);
                        }
                        if (textBoxOutlineInput) {
                            textBoxOutlineInput.checked = activeTextBox.dataset.outlineVisible !== '0';
                        }
                        if (textBoxFontColorInput) {
                            textBoxFontColorInput.value = activeTextBox.dataset.fontColor || '#0f172a';
                        }
                        if (textBoxBorderColorInput) {
                            textBoxBorderColorInput.value = activeTextBox.dataset.borderColor || '#3b82f6';
                        }
                        if (textBoxFontSizeInput) {
                            textBoxFontSizeInput.value = activeTextBox.dataset.fontSize || '32';
                        }
                    }
                }
            }

            function selectAll(el) {
                const range = document.createRange();
                range.selectNodeContents(el);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }

            function makeDraggable(el) {
                let dragging = false;
                let startX = 0;
                let startY = 0;
                let originX = 0;
                let originY = 0;

                el.addEventListener('mousedown', (e) => {
                    // Don't start drag if in editing mode
                    if (el.classList.contains('editing')) return;
                    if (e.button !== 0) return;

                    dragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    originX = parseFloat(el.style.left) || 0;
                    originY = parseFloat(el.style.top) || 0;
                    el.style.cursor = 'move';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    el.style.left = (originX + dx) + 'px';
                    el.style.top = (originY + dy) + 'px';
                });

                document.addEventListener('mouseup', () => {
                    if (!dragging) return;
                    dragging = false;
                    el.style.cursor = el.classList.contains('editing') ? 'text' : 'default';
                });
            }

            function createTextBox(x, y) {
                const box = document.createElement('div');
                box.className = 'wb-textbox active';
                box.dataset.id = 'tb-' + (++textBoxCounter);
                box.contentEditable = 'true';
                box.spellcheck = false;
                box.style.position = 'absolute';
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.style.minWidth = '180px';
                box.style.minHeight = '64px';
                box.style.width = '300px';
                box.style.padding = '10px 12px';
                box.style.border = '2px solid #3b82f6';
                box.style.borderRadius = '8px';
                box.style.color = '#0f172a';
                box.style.fontSize = '32px';
                box.style.lineHeight = '1.25';
                box.style.whiteSpace = 'pre-wrap';
                box.style.outline = 'none';
                box.style.resize = 'both';
                box.style.overflow = 'auto';
                box.style.cursor = 'text';
                box.textContent = 'Write here';

                const currentColor = textBoxBgColorInput ? textBoxBgColorInput.value : DEFAULT_TEXTBOX_BG;
                const currentOpacity = textBoxOpacityInput ? textBoxOpacityInput.value : String(DEFAULT_TEXTBOX_OPACITY);
                const currentOutline = textBoxOutlineInput ? textBoxOutlineInput.checked : DEFAULT_TEXTBOX_OUTLINE;
                const currentFontColor = textBoxFontColorInput ? textBoxFontColorInput.value : '#0f172a';
                const currentBorderColor = textBoxBorderColorInput ? textBoxBorderColorInput.value : '#3b82f6';
                const currentFontSize = textBoxFontSizeInput ? textBoxFontSizeInput.value : '32';
                applyTextBoxStyle(box, currentColor, currentOpacity);
                applyTextBoxOutline(box, currentOutline);
                box.style.color = currentFontColor;
                box.dataset.fontColor = currentFontColor;
                box.style.borderColor = currentBorderColor;
                box.dataset.borderColor = currentBorderColor;
                box.style.fontSize = currentFontSize + 'px';
                box.dataset.fontSize = currentFontSize;

                // Single click = select (draggable, show controls)
                // Double click = edit text
                box.contentEditable = 'false'; // start in select mode

                box.addEventListener('mousedown', (e) => {
                    setActiveTextBox(box, true);
                    clearLetterSelection();
                    e.stopPropagation();
                });

                box.addEventListener('dblclick', (e) => {
                    // Enter edit mode
                    box.contentEditable = 'true';
                    box.focus();
                    box.style.cursor = 'text';
                    box.classList.add('editing');
                    selectAll(box);
                    e.stopPropagation();
                });

                box.addEventListener('blur', () => {
                    // Exit edit mode on blur
                    box.contentEditable = 'false';
                    box.style.cursor = 'default';
                    box.classList.remove('editing');
                    if (box.textContent.trim() === '') {
                        box.remove();
                        if (activeTextBox === box) setActiveTextBox(null, false);
                    }
                });

                wbCanvas.appendChild(box);
                setActiveTextBox(box, true);
                makeDraggable(box);

                // New box starts in edit mode immediately
                requestAnimationFrame(() => {
                    box.contentEditable = 'true';
                    box.focus();
                    box.classList.add('editing');
                    selectAll(box);
                });
            }

            if (toolbarGroup && wbCanvas && wbCanvasContainer) {
                const textBoxBtn = document.createElement('button');
                textBoxBtn.className = 'btn btn-default';
                textBoxBtn.id = 'textBoxModeBtn';
                textBoxBtn.textContent = '📝';
                textBoxBtn.title = 'Text Box';
                textBoxBtn.style.cssText = 'font-size:16px;';

                if (textControlsGroup) {
                    textControlsGroup.insertBefore(textBoxBtn, textControlsGroup.firstChild);
                } else if (toolbarGroup) {
                    toolbarGroup.appendChild(textBoxBtn);
                }

                textBoxBtn.addEventListener('click', () => {
                    textBoxMode = !textBoxMode;
                    textBoxBtn.classList.toggle('active', textBoxMode);

                    if (typeof setMode === 'function') {
                        setMode(null);
                    } else if (typeof state !== 'undefined') {
                        state.mode = null;
                        if (typeof renderElements === 'function') renderElements();
                    }

                    if (typeof showToast === 'function') {
                        showToast(textBoxMode ? 'Text box mode: click canvas to insert' : 'Text box mode off');
                    }
                });

                wbCanvas.addEventListener('mousedown', (e) => {
                    if (!textBoxMode) return;
                    if (e.target !== wbCanvas) return;

                    e.preventDefault();
                    e.stopPropagation();

                    const rect = wbCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    createTextBox(x, y);

                    textBoxMode = false;
                    textBoxBtn.classList.remove('active');
                }, true);
            }

            if (textBoxBgColorInput) {
                textBoxBgColorInput.value = DEFAULT_TEXTBOX_BG;
                textBoxBgColorInput.addEventListener('input', () => {
                    if (!activeTextBox) return;
                    applyTextBoxStyle(activeTextBox, textBoxBgColorInput.value, textBoxOpacityInput ? textBoxOpacityInput.value : DEFAULT_TEXTBOX_OPACITY);
                });
            }

            if (textBoxOpacityInput) {
                textBoxOpacityInput.value = String(DEFAULT_TEXTBOX_OPACITY);
                textBoxOpacityInput.addEventListener('input', () => {
                    if (!activeTextBox) return;
                    applyTextBoxStyle(activeTextBox, textBoxBgColorInput ? textBoxBgColorInput.value : DEFAULT_TEXTBOX_BG, textBoxOpacityInput.value);
                });
            }

            if (textBoxOutlineInput) {
                textBoxOutlineInput.checked = DEFAULT_TEXTBOX_OUTLINE;
                textBoxOutlineInput.addEventListener('change', () => {
                    if (!activeTextBox) return;
                    applyTextBoxOutline(activeTextBox, textBoxOutlineInput.checked);
                });
            }

            if (textBoxFontColorInput) {
                textBoxFontColorInput.addEventListener('input', () => {
                    if (!activeTextBox) return;
                    activeTextBox.style.color = textBoxFontColorInput.value;
                    activeTextBox.dataset.fontColor = textBoxFontColorInput.value;
                });
            }

            if (textBoxBorderColorInput) {
                textBoxBorderColorInput.addEventListener('input', () => {
                    if (!activeTextBox) return;
                    activeTextBox.style.borderColor = textBoxBorderColorInput.value;
                    activeTextBox.dataset.borderColor = textBoxBorderColorInput.value;
                });
            }

            if (textBoxFontSizeInput) {
                textBoxFontSizeInput.addEventListener('change', () => {
                    if (!activeTextBox) return;
                    activeTextBox.style.fontSize = textBoxFontSizeInput.value + 'px';
                    activeTextBox.dataset.fontSize = textBoxFontSizeInput.value;
                });
            }

            // Delete active textbox with Delete key
            document.addEventListener('keydown', (e) => {
                if (!activeTextBox) return;
                if (document.activeElement === activeTextBox) return; // editing text
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    activeTextBox.remove();
                    setActiveTextBox(null, false);
                    if (typeof showToast === 'function') showToast('Text box избришан');
                }
            });

            wbCanvas.addEventListener('mousedown', (e) => {
                if (e.target === wbCanvas) {
                    setActiveTextBox(null, false);
                }
            }, true);

            document.addEventListener('mousedown', (e) => {
                const target = e.target instanceof Element ? e.target : null;
                if (!target) return;

                if (target.closest('.wb-textbox')) return;
                if (target.closest('#textBoxToolsGroup')) return;

                if (!target.closest('.element') && target !== wbCanvas) {
                    setActiveTextBox(null, false);
                }
            });

            window.addEventListener('message', (event) => {
                const data = event.data || {};
                if (data.type !== 'insert-generated-image' || !data.url) return;

                const img = new Image();
                img.onload = () => {
                    const maxW = 420;
                    const scale = img.width > maxW ? maxW / img.width : 1;
                    const width = Math.round(img.width * scale);
                    const height = Math.round(img.height * scale);
                    const fallbackPoint = {
                        x: (wbCanvasContainer?.scrollLeft || 0) + (wbCanvasContainer?.clientWidth || 0) / 2,
                        y: (wbCanvasContainer?.scrollTop || 0) + (wbCanvasContainer?.clientHeight || 0) / 2
                    };
                    const point = typeof getDefaultInsertPoint === 'function' ? getDefaultInsertPoint() : fallbackPoint;
                    const x = Math.max(0, point.x - width / 2);
                    const y = Math.max(0, point.y - height / 2);

                    if (typeof saveToHistory === 'function') saveToHistory();
                    const inserted = {
                        id: generateId(),
                        type: 'image',
                        content: data.url,
                        x,
                        y,
                        width,
                        height
                    };
                    state.elements.push(inserted);
                    if (Array.isArray(state.selectedIds)) state.selectedIds = [inserted.id];
                    if (typeof updateSelectionTools === 'function') updateSelectionTools();
                    if (typeof renderElements === 'function') renderElements();
                    if (typeof showToast === 'function') showToast('Сликата е вметната');
                };

                img.onerror = () => {
                    if (typeof showToast === 'function') showToast('Сликата не се вчита');
                };

                img.src = data.url;
            });
        })();
    </script></body>
</html>

    </template>

    <script>
        const tabs = Array.from(document.querySelectorAll('.nav-tab'));
        const panels = {
            card: document.getElementById('panel-card'),
            whiteboard: document.getElementById('panel-whiteboard')
        };

        function activateTab(target) {
            tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.target === target));
            Object.entries(panels).forEach(([name, panel]) => {
                if (panel) panel.classList.toggle('active', name === target);
            });
        }

        tabs.forEach(btn => {
            btn.addEventListener('click', () => activateTab(btn.dataset.target));
        });

        const cardFrame = document.getElementById('cardFrame');
        const whiteboardFrame = document.getElementById('whiteboardFrame');
        const cardHtml = document.getElementById('cardTemplate').innerHTML;
        const whiteboardHtml = document.getElementById('whiteboardTemplate').innerHTML;

        cardFrame.srcdoc = cardHtml;
        whiteboardFrame.srcdoc = whiteboardHtml;
        window.addEventListener('message', (event) => {
            if (event.source !== cardFrame.contentWindow) return;
            const data = event.data || {};
            if (data.type !== 'insert-generated-image' || !data.url) return;
            if (!whiteboardFrame || !whiteboardFrame.contentWindow) return;

            whiteboardFrame.contentWindow.postMessage({
                type: 'insert-generated-image',
                url: data.url
            }, '*');
            activateTab('whiteboard');
        });
    </script>
</body>
</html>
